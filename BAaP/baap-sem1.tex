\documentclass[14pt, a4paper]{extarticle}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{multirow}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{listing}

\begin{document}
\title{Ответы по ОАиПу}
\maketitle

\newcommand{\itembf}[1]{\item \textbf{#1}}
\newtheorem*{defin}{Определение} % [subsection]
\newtheorem*{theorem}{Теорема} % [subsection]

\newpage
\tableofcontents
\newpage

\setcounter{section}{36}

\section{Операции над указателями разного порядка}

\section{Арифметика указателей}

\section{Массивы переменных размеров. Аллокаторы памяти}
\textbf{Массив} — это определённое число ячеек памяти, расположенных непосредственно друг за другом.
Массив позволяет хранить несколько значений одинакового типа.

Поскольку число элементов массива переменной длины и, следовательно, его размер заранее неизвестны,
память для него обычно выделяется в куче. Доступ к элементам массива при этом осуществляется через
указатель на первый элемент массива при помощи арифметики указателей или оператора \verb|[]|

Существует три различных подхода к выделению динамической памяти:
\begin{enumerate}
  \item Функциии \verb|malloc, realloc, calloc|.
  Для первоначального выделения памяти можно использовать любую из этих функций.
  Для изменения размера выделенного участка памяти необходимо использовать 
  функцию \verb|realloc|. Она либо расширяет старый участок памяти, либо выделяет память
  заново, копирую при этом туда нужное число элементов (минимум от старого и нового размеров) и
  освобждая после этого старый участок.

  \begin{verbatim}
    // Выделение памяти
    int *array = (int*) malloc(sizeof(int) * array_size);

    // Изменение размера
    array = (int*) realloc(sizeof(int) * new_array_size);

    // Освобождение памяти
    free(array);
  \end{verbatim}
  
  \item Оператор \verb|new|
  Язык C++ не предоставляет аналога функции \verb|realloc| из C. Поэтому для изменения размера массива
  необходимо выделить память заново и вручную скопировать (переместить, если в массиве лежит что-то сложнее \verb|int|ов)
  в новую область памяти существующие элементы массива.
  \begin{verbatim}
    // Выделение памяти
    int *array = new int[array_size];

    // Изменение размера
    int *new_array = new int[new_array_size];
    int copy_size = std::min(array_size, new_array_size);
    for (int i = 0; i < copy_size; ++i) {
      new_array[i] = array[i]; // Или std::move(array[i]);
    }
    delete[] array;
    array = new_array;

    // Освобождение памяти
    delete[] array;
  \end{verbatim}
\end{enumerate}
Работа с памятью в стиле языка Си в некоторых случаях\footnote{Почти всегда?} позволяет ускорить
перевыделение памяти\footnote{Также функции выделения памяти обычно устроены так, чтобы сократить число системных вызовов},
поскольку избегает копирования всех элементов массива, однако возлагает на программиста
ответственность за ручной вызов деструкторов и placement new, если приходится работать
с более сложными объектами.

Аллокатор --- высокоуровневая абстракция над выделением и освобождением памяти,
которая позволяет задать конекретный способ того, как будет выделяться память.
Применение аллокаторов оправдано, когда программист знает, как именно его программа
использует память. В таком случае аллокаторы позволяют сократить число системных вызовов
и ускорить работу программы.

\section{Рекурсивные алгоритмы}
\textbf{Рекурсивная функция} -- такая функция, которая вызывает саму себя.
Тривиальным примером рекурсивной функции может служить функция для вычисления
чисел Фибоначчи, определяемых рекуррентным соотношением $f_n = f_{n-1} + f_{n-2}$, причем $f_1 = f_2 = 1$:
\begin{verbatim}
long FibRecursion(long n) {
  if (n == 1 || n == 2) {
    return 1;
  }
  return Fib(n - 1) + Fib(n - 2);
}  
\end{verbatim}
% \begin{verbatim}
% long FibLoop(long n) {
%   long f1 = 1;
%   long f2 = 1;
%   for (int i = 1; i <= n; ++i) {
%     f1 += f2;
%     std::swap(f1, f2);
%   }
%   return f2;
% }
% \end{verbatim}

Математически доказуемо, что любой рекурсивный алгоритм можно реализовать с помощью цикла
и обратно: любой циклический алгоритм можно реализовать с помощью рекурсии.

Обычно рекурсивные алгоритмы более наглядные и простые. Благодаря этому рекурсия нашла довольно
широкое применение в различных алгоритмах (Quicksort, обход вершин графов).

Однако рекурсивные алгоритмы из-за накладных раходов на вызов функции обычно показывают худшую
производительность\footnote{и Time, и Space Complexity}, чем циклические, несмотря на одинаковую
асимптотику. Кроме того, для работы рекурсивных алгоритмов необходимо поддерживать стек вызовов.
Но размер стека ограничен\footnote{как?}, что накладывает ограничение на максимальную глубину рекурсии.

Из-за кривого дизайна (как в примере выше) выполнение функции может иметь
экспоненциальную сложность. Например, для вычисления 10-го числа Фибоначчи эта функция
два раза вычислит 9-ое число, для чего ей понадобится 4 раза вычислить 8-ое и т.\,д. Чтобы
избежать повторных вычислений, применяют подход, называемый \textbf{мемоизацией}: после вычисления
функции для заданного значения аргумента оно сохраняется в памяти, а при повторных запросах функция
возвращает уже вычисленное значение. Применение мемоизации позволяет снизить алгоритмическую сложность
до $O(n)$ (в данном примере), пожертвовав дополнительной памятью \footnote{Поскольку рекурсия использует
стек вызовов глубины $n$ и сохраяняет $n$ значений, Space Complexity не изменится и составит $O(n)$,
что все еще хуже циклического алгоритма.}.

\section{Алгоритмы сортировки. Асимптотическая сложность}
\textbf{Сортировка} --- процесс расположения элементов массива (последовательности) в определенном
порядке, удобоном для работы. Если отсортировать массив чисел в порядке убывания, то первый элемент
всегда будет наибольшим, а последний наименьшим.
Сортировки имеют важное прикладное значение. Например, с отсортированными данными иногда можно
работать более эффективно, чем с неупорядоченными (бинарный поиск имеет сложность $O(\log n)$, а
линейный --- $O(n)$).

Алгоритм сортировки называется \textbf{устойчивым} (stable), если он сохраняет порядок следования
элементов с совпадающим значением ключа --- признака, по которому происходит сравнение.

Алгоритмическая сложность многих алгоритмов сортировки может зависеть от входных данных
\footnote{Здесь и далее, если не указано иное, за $n$ принимается размер массива}.

Можно доказать, что асимптотическая сложность сортировки, основанной на сравнениях, не может
быть лучше, чем $O(n\cdot \log n)$. При этом существуют алгоритмы сортировки, которые используют
знания о природе сортируемых данных и имеют сложность $O(n)$ в среднем, однако они могут быть
неприменимы в общем случае.

Ниже приведены и кратко описаны некоторые алгоритмы сортировки. Для простоты будем считать,
что мы сортируем массивы чисел по возрастанию.

\paragraph{Пузырьковая сортировка.} Самый дурацкий алгоритм сортировки. Выполняет проходы по массиву
до тех пор, пока массив не будет отсортирован. Если во время прохода встретится пара элементов, которые
непосредственно идут друг за другом и имеют неверный порядок, то они меняются местами. Time Complexity --- $O(n^2)$,
Space Complexity --- $O(1)$.

\paragraph{Сортировка выбором.} В первом проходе выбирает наименьший элемент массива и меняет его местами с первым.
На следующем этапе проходит по массиву начиная со второго элемента и выбирает наименьший элемент из этой части массива,
после чего меняет его местами со вторым элементом массива. Повторяет этот шаг до тех пор, пока не останется один
элемент. Массив отсортирован. Time Complexity --- $O(n^2)$, Space Complexity --- $O(1)$.

\paragraph{Сортировка вставками.} 
Перебираются элементы в неотсортированной части массива.
Каждый элемент вставляется в отсортированную часть массива на то место, где он должен находиться.
Time Complexity --- $O(n^2)$ в худшем случае и $O(n)$, если массив уже отсортирован. Space Complexity --- $O(1)$.

{\small
Сортировка вставками имеет довольно маленькую константу, блягодаря чему используется в функции \verb|std::sort|
для сортировки небольших массивов или маленьких частей больших массивов как часть следующего алгоритма.
}
\paragraph{Быстрая сортировка.} 

\paragraph{Сортировка слиянием.}
Разделяет исходный массив на два равных подмассива, после чего рекурсивно сортирует ихпо отдельности и объединяет.
Массивы разделяются до тех пор, пока в них не останется одного элемента.

Алгоритм сортировки таков:
\begin{enumerate}
  \item Если в массиве 1 элемент --- завершиться.
  \item Найти середину массива.
  \item Посортировать первую половину.
  \item Посортировать вторую половину.
  \item Объединить массив.
\end{enumerate}

Алгоритм объединения массивов:
\begin{enumerate}
  \item Циклично проходим по двум массивам.
  \item В объединяемый ставим тот элемент, что меньше.
  \item Двигаемся дальше, пока не дойдем до конца обоих массивов.
\end{enumerate}

Time Complexity: $O(n\log n)$, Space Complexity: $O(n)$.

\paragraph{Сортировка Шелла.}

\paragraph{Сортировка кучей.}

\section{Функции языка С для работы со строками}
\textbf{Строки} используются для представления текстовой информации.
В языке C строки рассматриваются как массивы символов (\verb|char|), заканчивающиеся
специальным зарезервированным символом с кодом 0.

% Также существуют (но реже используются) <<широкие>> строки, которые являются аналогичными
% массивами символов \verb|wchar_t|.

Прототипы функций для работы со строками в языке C находятся в заголовочном файле \verb|<string.h>|
(в языке C++ для работы с C-строками --- \verb|<cstring>|).

\verb|size_t strlen(const char *s)| - определяет длину строки \verb|s| без учёта нуль-символа.

\subsection*{Копирование строк}

\verb|char *strcpy(char *dst, const char *src)| --- выполняет побайтное копирование символов из строки \verb|src|
в строку \verb|dst|. Возвращает указатель \verb|dst|. Программист должен удостовериться, что \verb|dst| указывает
на участко памяти достаточного размера.

strncpy(s1,s2, n) - выполняет побайтное копирование n символов из строки  s2 в строку s1. возвращает значения s1
Конкатенация строк

\verb|char* strcat(char *dst, const char *src)| - объединяет строку \verb|src| со строкой \verb|dst|.
Результат сохраняется в \verb|dst|. 

strncat(s1,s2,n) - объединяет n символов строки s2 со строкой s1. Результат сохраняется в s1
\subsection*{Сравнение строк}

strcmp(s1,s2) - сравнивает строку s1 со строкой s2 и возвращает результат типа int: 0 –если строки эквивалентны, >0 – если s1<s2,  <0  — если s1>s2 С учётом регистра

strncmp(s1,s2,n) - сравнивает n символов строки s1 со строкой s2 и возвращает результат типа int: 0 –если строки эквивалентны, >0 – если s1<s2,  <0  — если s1>s2 С учётом регистра

stricmp(s1,s2) - сравнивает строку s1 со строкой s2 и возвращает результат типа int: 0 –если строки эквивалентны, >0 – если s1<s2,  <0  — если s1>s2 Без учёта регистра

strnicmp(s1,s2,n) - сравнивает n символов строки s1 со строкой s2 и возвращает результат типа int: 0 –если строки эквивалентны, >0 – если s1<s2,  <0 — если s1>s2 Без учёта регистра
\subsection*{Обработка символов}

isalnum(c) - возвращает значение true, если с является буквой или цифрой, и false в других случаях

isalpha(c) - возвращает значение true, если с является буквой,  и false в других случаях

isdigit(c) - возвращает значение true, если с является цифрой, и false в других случаях

islower(c) - возвращает значение true, если с является буквой нижнего регистра, и false в других случаях

isupper(c) - возвращает значение true, если с является буквой верхнего регистра, и false в других случаях

isspace(c) - возвращает значение true, если с является пробелом, и false в других случаях

toupper(c) - если символ с, является символом нижнего регистра, то функция возвращает преобразованный символ с в верхнем регистре, иначе символ возвращается без изменений.
\subsection*{Функции поиска}

strchr(s,c) -  поиск первого вхождения символа с в строке s. В случае удачного поиска возвращает указатель на место первого вхождения символа с. Если символ не найден, то возвращается ноль.

strcspn(s1,s2) - определяет длину начального сегмента строки s1, содержащего те символы, которые не входят в строку s2

strspn(s1,s2) - возвращает длину начального сегмента строки s1, содержащего только те символы, которые входят в строку s2

strprbk(s1,s2) - Возвращает указатель  первого вхождения любого символа строки s2 в строке s1

\subsection*{Функции преобразования}

atof(s1) - преобразует строку s1 в тип double

atoi(s1) - преобразует строку s1 в тип int

atol(s1) - преобразует строку s1 в тип long int
Функции стандартной библиотеки ввода/вывода <stdio>

getchar(с) - считывает символ с со стандартного потока ввода, возвращает символ в формате int

gets(s) - считывает поток символов со стандартного устройства ввода в строку s до тех пор, пока не будет нажата клавиша ENTER

\vspace{1cm}

Функции для работы с Си-строками никогда не выделяют память, если оказывается, что размер буфера недостаточен. Это 
может привести к неопределенному поведению и ощибкам сегментации. О выделении
достаточного размера памяти должен заботиться программист, который вызывает функцию.

\section{Методы языка С++ для работы со строками}

\section{Декларация структур (struct) в С/С++. Отличия в декларации}
\textbf{Структура} --- 

\section{Инициализация и доступ к элементам структуры. Выравнивание}

\section{Вложенные структуры и массивы структур}

\section{Указатели на структуры}

\section{Объединения и битовые поля}

\section{Локальные и глобальные переменные}

\section{Автоматические переменные}

\section{Внешние и статические переменные, особенности их реализации}

\newpage
\section{Символические константы: \#define. Включение файла: \#include}
\paragraph{\#include} подставляет вместо себя содержимое указанного файла. Синтаксис:
\begin{verbatim}
  #include <файл>
\end{verbatim}
или
\begin{verbatim}
  #include "файл"
\end{verbatim}
Подключаемый файл может находиться либо в той же директории, в которой лежит и исходный файл,
либо в одном из системных путей:
\begin{itemize}
  \item Linux(компилятор GCC):
  \begin{itemize}
    \item \verb|/usr/include/c++/14.2.1|
    \item \verb|/usr/include/c++/14.2.1/x86_64-pc-linux-gnu|
    \item \verb|/usr/include/c++/14.2.1/backward|
    \item \verb|/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include|
    \item \verb|/usr/local/include|
    \item \verb|/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include-fixed|
    \item \verb|/usr/include|
  \end{itemize}
  Компилятор Clang использует те же самые пути (в том числе и GCC), но добавляет один путь: \verb|/usr/lib/clang/18/include|
\end{itemize}

При использовании синтаксиса с кавычками препроцессор сначала ищет файлы в той же директории,
где находится и файл, и только потом --- в системных путях; а при использовании треугольных скобок --- наоборот.
Также отметим, что можно добавить системные пути с помощью флага \verb|-I| (GCC, clang) или \verb|/I| (MSVC) компилятора.
Руководство по стилю кода Google рекомендует использование \verb|<>| для подключения заголовков сторонних и стандартной
библиотек и \verb|""| для подключения заголовков текущего проекта.

Как правило, директива \verb|#include| для подключения заголовочных файлов, содержащих
объявления функций, структур, классов и т.\,д. Например, в заголовочном файле \verb|cmath|
стандартной библиотеки содержатся объявления математических функций \verb|std::sqrt|, \verb|std::sin|,
\verb|std::round| и других. В файле \verb|iostream| содержатся функции и структуры для ввода-вывода информации
в консоль.

\paragraph{\#define} позволяет определять символьные константы\footnote{для краткости я буду их называть макросами,
но гипотетически Вадим может к этому придраться} (англ. macro), вместо которых будет подставляться указанное выражение.
Синтаксис таков:
\begin{verbatim}
  #define идентификатор выражение
  #define идентификатор(параметры, через, запятую) выражение
\end{verbatim}
где \verb|идентификатор| --- это имя макроса (любой валидный идентификатор),
а \verb|выражение| --- то, что будет подставляться вместо \verb|идентификатор|а.

В первом случае директива создает символическую константу (object-like macro),
вместо которой просто подставляется выражение.

Во втором случае директива создает функциональный макрос (function-like macro),
в которые можно передать несколько аргументов. Они будут подставлены в выражение
вместо параметров (см. пример). Поскольку в качестве аргумента макроса может
выступать любое выражение, которое подставляется в макрос прямым текстом, <<как есть>>,
параметры при использовании следует оборачивать в скобки, чтобы избежать неожиданных результатов
(ср. \verb|MUL| и \verb|CORRECT_MUL| в примере).

В выражении функционального макроса можно использовать два специальных оператора:
\verb|#параметр|, который оборачивает значение \verb|параметра| в кавычки,
превращая его в строковый литерал и \verb|#|, который позволяет сконкатенировать
параметр с чем угодно.

В \verb|выражении| можно использовать другие макросы, а в процедурные макросы можно передавать
другие макросы(в том числе и процедурные).

Отметим, что \verb|выражение| может быть пустым (в таком случае
вместо макроса подставится ничто). Также любой макрос можно впоследствии переопределить
с помощью директивы \verb|#define| либо разопределить с помощью директивы \verb|#undef|.
Тогда после разопределения макроса компилятор будет вести себя так, как будто этого
макроса никогда и не было; но в коде между \verb|#define| и \verb|#undef| этот макрос
будет доступен.

{\small В C++11 появилась возможность создавать макросы с переменным числом параметров.
Эта ужасно страшное колдунство. Подробнее смотри по ссылке:
\url{https://en.cppreference.com/w/cpp/preprocessor/replace}}

Пример:
\begin{verbatim}
#define QUESTION 52
#define ANSWER 42
#define SUM QUESTION + ANSWER
#define MERGE(x) v##x
#define MKSTRING(x) #x

#define MUL(x, y) x*y
#define CORRECT_MUL(x, y) (x) * (y)

int v42 = 24;
int vANSWER = -24;

// 10 94
std::cout << QUESTION - ANSWER << ' ' << SUM << '\n';
// 24 0
std::cout << MERGE(42) << ' ' << MERGE(42) + MERGE(ANSWER) << '\n';
// All human beings are born free and equal
std::cout << MKSTRING(All human beings are born free and equal) << '\n';
// 5 9
std::cout << MUL(3, 1 + 2) << ' ' << CORRECT_MUL(3, 1 + 2) << '\n';

#undef ANSWER
// Ошибка компиляции
std::cout << ANSWER << '\n';
\end{verbatim}


\section{Директивы препроцессора: \#if, \#ifdef, \#ifndef, \#else, \#endif}
Эти директивы препроцессора предназначены для условной компиляции, то есть они позволяют
включить или выключить компиляцию определенных участков кода. Директивы создают ветвления
на этапе препроцессора.

\paragraph{\#if} имеет следующий синтаксис:
\begin{verbatim}
#if <условие>
// скомпилировать код
#endif
\end{verbatim}
Подобно оператору(?) ветвления в C++, включает компиляцию нижеследующего
участка кода, если выполнено заданное условие. В условии можно использовать:
\begin{itemize}
  \item Числовые и символьные константы (\verb|42, 'Y'|)
  \item Арифметические, побитовые и логические операции
  \item Макросы
  \item Оператор \verb|defined(<макрос>)|. Если \verb|<макрос>| был ранее по тексту программы определен с помощью директивы препроцессора
  \verb|#define|, то оператор возвращает 1, иначе -- 0
  \item Идентификаторы, которые не являются ранее определенными макросами. Вместо них подставляется число 0.
\end{itemize}
Если при вычислении записанного в условии выражения получится 0, то оно считается ложным; если же выйдет любое ненулевое число --- истинным.

Следует отметить, что в директивах нельзя использовать оператор \verb|sizeof|, поскольку препроцессор ничегно не знает о типах.

Также существует директива препроцессора \verb|#elif|, которая является полным аналогом конструкции \verb|else if|.

\paragraph{\#ifdef, \#ifndef} имеют одинаковый синтаксис:
\begin{verbatim}
#ifdef <макрос>
// скомпилировать код
#endif

#ifndef <макрос>
// скомпилировать код
#endif
\end{verbatim}

Директива \verb|#ifdef| включает компиляцию участка кода, если \verb|<макрос>| был ранее определен с помощью директивы \verb|#defined|.

Директива \verb|#ifndef|, наоборот, включает компиляцию участка кода, если \verb|<макрос>| \textbf{не} был ранее определен
с помощью директивы \verb|#defined|.

{\small \textit{Примечание. Макросы можно разопределить с помощью директивы} \verb|#undef| }

\paragraph{\#else} может использоваться только в связке с вышеназванными директивами:
\begin{verbatim}
#ifndef <условие>
  // скомпилировать, если <условие> выполнено
#else
  // скомпилировать, если <условие> не выполнено
#endif
\end{verbatim}

Если оказывается, что условие директив \verb|#if, #ifdef, #ifndef| ложно, то все то, что находится между директивами \verb|#if|
и \verb|#else| игнорируется, а компилируется то, что находится между \verb|#else| и \verb|#endif|.

\paragraph{\#endif} обозначает конец ветвления.

Эти директивы можно использовать для определения операционной системы (проверка макросов \verb|__linux__|, \verb|__ANDROID__|, \verb|_WIN32|, \verb|macintosh|),
различения C и C++ (макрос \verb|__cplusplus|).

Также Руководство по стилю кода Google рекомендует использовать эти директивы для предотвращения повторного включения одного
и того же файла (include guards):
\begin{verbatim}
#ifdef MY_FANCY_HEADER_H_
#define MY_FANCY_HEADER_H_ 1

int Sum(int a, int b);
int Odd(int a, int b);
typedef int(*FunctionPtr)(int, int);

#endif // MY_FANCY_HEADER_H_
\end{verbatim}

Более сложный и бесполезный пример:
\begin{verbatim}
#ifndef __cplusplus
#include <stdio.h>
void SayHi() {
  printf("Thou usest C!\n");
}
#elif __cplusplus >= 202300L
#include <print>
void SayHi() {
  std::print("Your C++ version is {}, supergood!\n",
             __cplusplus);
}
#else
#include <iostream>
void SayHi() {
  std::cout << "Your C++ version is "
            << __cplusplus << ", kinda old :(\n";
}
#endif

int main() {
  SayHi();
  return 0;
}
\end{verbatim}

\url{https://gcc.gnu.org/onlinedocs/cpp/If.html}

\url{https://sourceforge.net/p/predef/wiki/OperatingSystems/}

\section{Понятие алгоритма. Введение в алгоритмизацию}

\end{document}