\documentclass[14pt, a4paper]{extarticle}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{multirow}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{listing}

\begin{document}
\title{Ответы по ОАиПу}
\maketitle
\vspace{6cm}
\begin{center}
  Это предварительная версия. Здесь косноязычие может встретиться, како и очепятки,
  \\
  \hspace*{12cm} и \verb|к|\textbf{р}\textit{и}\textsuperscript{в}\textsubscript{о}е.
\end{center}
форматирование.

\newcommand{\itembf}[1]{\item \textbf{#1}}
\newtheorem*{defin}{Определение} % [subsection]
\newtheorem*{theorem}{Теорема} % [subsection]

\newpage
\tableofcontents
\newpage

\setcounter{section}{36}

\section{Операции над указателями разного порядка}

Над указателями можно совершать следующие операции:

\section{Арифметика указателей}
\label{sec:ptr_arithm}
\textbf{Указатель} --- переменная, значением которой является адрес памяти.
В памяти указатель представляется как беззнаковое целое длины, равной длине
машинного слова.
\textit{Одноименными} будем называть указатели, которые указывают на переменные
одинакового типа. По стандарту арифметические операции нельзя совершать над 
указателями на \verb|void|\footnote{точнее, на неполные типы (incomplete types ---
types that describe objects but lack information needed to determine their sizes)}
и функции, хотя GCC разрешает эти операции в качестве расширения.

К арифметическим операциям над указательями относятся следующие операции:
\begin{enumerate}
  \itembf{Сложение с числом.} К указателю можно прибавлять как положительные,
  так и отрицательные числа. Эта операция коммутативна. При прибавлении к указателю
  \verb|a| числа \verb|n|, значение адреса памяти, на котороый указвает указатель,
  увеличивается на \verb|n*sizeof(int)|\footnote{или не int, а нужного типа.}
  Для удобства выражение \verb|*(a + n)| можно записывать как \verb|a[n]|.
  Пример (выведет \verb|OK|):
\begin{verbatim}
  int n = 4;
  if (((unsigned long) (a+n)) ==
      ((unsigned long) a) + (n*sizeof(int))) {
        std::cout << "OK\n";
  }
\end{verbatim}

  \itembf{Инкремент и декремент} прибавляет и отнимает единицу к указателю (\textbf{не} к адресу!) по правилу, указанному
  выше, соответственно. При этом, как и с обычными чисами, префиксные операторы возвращают измененное
  значение, а постфиксные --- неизмененное.

  Единственное, следует обратить внимание на приоритет оператора инекремента (декремента)
  и оператора разыменования \verb|*|. При использовании как префиксного, так и постфиксного
  оператора сначала выполнится инкремент (декремент) и только потом --- разыменование.
\begin{verbatim}
int c[2]{5, 10};
int *b = c;
// 5 (b до изменения указывает на c[0])
std::cout << *b++ << '\n';
// Теперь b указывает на c[1]
// 10 | 5 10
std::cout << *b << " | " << c[0] << ' '
                          << c[1] << '\n';
\end{verbatim}

  \itembf{Вычитание числа из указателя} работает так же, как и прибавление к указателю
  числа, противоположного по знаку.
  \itembf{Вычитание одноименных указателей} \verb|a - b| возвращает такое число \verb|n|,
  что \verb|a == b + n|. Число \verb|n| имеет тип \verb|ptrdiff_t| из \verb|<cstddef>|,
  который является \verb|typedef|'ом от какого-то\footnote{implementation-defined} обычного
  \textit{знакового} целочисленного типа.
\begin{verbatim}
int a[20]{};
int *b = a;
int *c = a + 12;
// 12
std::cout << c - b << '\n';
// -12
std::cout << b - c << '\n';
\end{verbatim}
  Если результат вычитания настолько большой, что не может поместиться в \verb|ptrdiff_t|,
  то UB.
\end{enumerate}

\section{Массивы переменных размеров. Аллокаторы памяти}
\textbf{Массив} — это определённое число ячеек памяти, расположенных непосредственно друг за другом.
Массив позволяет хранить несколько значений одинакового типа.

Поскольку число элементов массива переменной длины и, следовательно, его размер заранее неизвестны,
память для него обычно выделяется в куче. Доступ к элементам массива при этом осуществляется через
указатель на первый элемент массива при помощи арифметики указателей или оператора \verb|[]|

Существует три различных подхода к выделению динамической памяти:
\begin{enumerate}
  \item Функциии \verb|malloc, realloc, calloc|.
  Для первоначального выделения памяти можно использовать любую из этих функций.
  Для изменения размера выделенного участка памяти необходимо использовать 
  функцию \verb|realloc|. Она либо расширяет старый участок памяти, либо выделяет память
  заново, копирую при этом туда нужное число элементов (минимум от старого и нового размеров) и
  освобждая после этого старый участок.

  \begin{verbatim}
    // Выделение памяти
    int *array = (int*) malloc(sizeof(int) * array_size);

    // Изменение размера
    array = (int*) realloc(sizeof(int) * new_array_size);

    // Освобождение памяти
    free(array);
  \end{verbatim}
  
  \item Оператор \verb|new|
  Язык C++ не предоставляет аналога функции \verb|realloc| из C. Поэтому для изменения размера массива
  необходимо выделить память заново и вручную скопировать (переместить, если в массиве лежит что-то сложнее \verb|int|ов)
  в новую область памяти существующие элементы массива.
  \begin{verbatim}
    // Выделение памяти
    int *array = new int[array_size];

    // Изменение размера
    int *new_array = new int[new_array_size];
    int copy_size = std::min(array_size, new_array_size);
    for (int i = 0; i < copy_size; ++i) {
      new_array[i] = array[i]; // Или std::move(array[i]);
    }
    delete[] array;
    array = new_array;

    // Освобождение памяти
    delete[] array;
  \end{verbatim}
\end{enumerate}
Работа с памятью в стиле языка Си в некоторых случаях\footnote{Почти всегда?} позволяет ускорить
перевыделение памяти\footnote{Также функции выделения памяти обычно устроены так, чтобы сократить число системных вызовов},
поскольку избегает копирования всех элементов массива, однако возлагает на программиста
ответственность за ручной вызов деструкторов и placement new, если приходится работать
с более сложными объектами.

Аллокатор --- высокоуровневая абстракция над выделением и освобождением памяти,
которая позволяет задать конекретный способ того, как будет выделяться память.
Применение аллокаторов оправдано, когда программист знает, как именно его программа
использует память. В таком случае аллокаторы позволяют сократить число системных вызовов
и ускорить работу программы.

\section{Рекурсивные алгоритмы}
\textbf{Рекурсивная функция} -- такая функция, которая вызывает саму себя.
Тривиальным примером рекурсивной функции может служить функция для вычисления
чисел Фибоначчи, определяемых рекуррентным соотношением $f_n = f_{n-1} + f_{n-2}$, причем $f_1 = f_2 = 1$:
\begin{verbatim}
long FibRecursion(long n) {
  if (n == 1 || n == 2) {
    return 1;
  }
  return Fib(n - 1) + Fib(n - 2);
}  
\end{verbatim}
% \begin{verbatim}
% long FibLoop(long n) {
%   long f1 = 1;
%   long f2 = 1;
%   for (int i = 1; i <= n; ++i) {
%     f1 += f2;
%     std::swap(f1, f2);
%   }
%   return f2;
% }
% \end{verbatim}

Математически доказуемо, что любой рекурсивный алгоритм можно реализовать с помощью цикла
и обратно: любой циклический алгоритм можно реализовать с помощью рекурсии.

Обычно рекурсивные алгоритмы более наглядные и простые. Благодаря этому рекурсия нашла довольно
широкое применение в различных алгоритмах (Quicksort, обход вершин графов).

Однако рекурсивные алгоритмы из-за накладных раходов на вызов функции обычно показывают худшую
производительность\footnote{и Time, и Space Complexity}, чем циклические, несмотря на одинаковую
асимптотику. Кроме того, для работы рекурсивных алгоритмов необходимо поддерживать стек вызовов.
Но размер стека ограничен\footnote{как?}, что накладывает ограничение на максимальную глубину рекурсии.

Из-за кривого дизайна (как в примере выше) выполнение функции может иметь
экспоненциальную сложность. Например, для вычисления 10-го числа Фибоначчи эта функция
два раза вычислит 9-ое число, для чего ей понадобится 4 раза вычислить 8-ое и т.\,д. Чтобы
избежать повторных вычислений, применяют подход, называемый \textbf{мемоизацией}: после вычисления
функции для заданного значения аргумента оно сохраняется в памяти, а при повторных запросах функция
возвращает уже вычисленное значение. Применение мемоизации позволяет снизить алгоритмическую сложность
до $O(n)$ (в данном примере), пожертвовав дополнительной памятью \footnote{Поскольку рекурсия использует
стек вызовов глубины $n$ и сохраяняет $n$ значений, Space Complexity не изменится и составит $O(n)$,
что все еще хуже циклического алгоритма.}.

\section{Алгоритмы сортировки. Асимптотическая сложность}
\textbf{Сортировка} --- процесс расположения элементов массива (последовательности) в определенном
порядке, удобоном для работы. Если отсортировать массив чисел в порядке убывания, то первый элемент
всегда будет наибольшим, а последний наименьшим.
Сортировки имеют важное прикладное значение. Например, с отсортированными данными иногда можно
работать более эффективно, чем с неупорядоченными (бинарный поиск имеет сложность $O(\log n)$, а
линейный --- $O(n)$).

Алгоритм сортировки называется \textbf{устойчивым} (stable), если он сохраняет порядок следования
элементов с совпадающим значением ключа --- признака, по которому происходит сравнение.

Алгоритмическая сложность многих алгоритмов сортировки может зависеть от входных данных
\footnote{Здесь и далее, если не указано иное, за $n$ принимается размер массива}.

Можно доказать, что асимптотическая сложность сортировки, основанной на сравнениях, не может
быть лучше, чем $O(n\cdot \log n)$. При этом существуют алгоритмы сортировки, которые используют
знания о природе сортируемых данных и имеют сложность $O(n)$ в среднем, однако они могут быть
неприменимы в общем случае.

Ниже приведены и кратко описаны некоторые алгоритмы сортировки. Для простоты будем считать,
что мы сортируем массивы чисел по возрастанию.

\paragraph{Пузырьковая сортировка.} Самый дурацкий алгоритм сортировки. Выполняет проходы по массиву
до тех пор, пока массив не будет отсортирован. Если во время прохода встретится пара элементов, которые
непосредственно идут друг за другом и имеют неверный порядок, то они меняются местами. Time Complexity --- $O(n^2)$,
Space Complexity --- $O(1)$.

\paragraph{Сортировка выбором.} В первом проходе выбирает наименьший элемент массива и меняет его местами с первым.
На следующем этапе проходит по массиву начиная со второго элемента и выбирает наименьший элемент из этой части массива,
после чего меняет его местами со вторым элементом массива. Повторяет этот шаг до тех пор, пока не останется один
элемент. Массив отсортирован. Time Complexity --- $O(n^2)$, Space Complexity --- $O(1)$.

\paragraph{Сортировка вставками.} 
Перебираются элементы в неотсортированной части массива.
Каждый элемент вставляется в отсортированную часть массива на то место, где он должен находиться.
Time Complexity --- $O(n^2)$ в худшем случае и $O(n)$, если массив уже отсортирован. Space Complexity --- $O(1)$.

{\small
Сортировка вставками имеет довольно маленькую константу, блягодаря чему используется в функции \verb|std::sort|
для сортировки небольших массивов или маленьких частей больших массивов как часть следующего алгоритма.
}
\paragraph{Быстрая сортировка.} 

\paragraph{Сортировка слиянием.}
Разделяет исходный массив на два равных подмассива, после чего рекурсивно сортирует ихпо отдельности и объединяет.
Массивы разделяются до тех пор, пока в них не останется одного элемента.

Алгоритм сортировки таков:
\begin{enumerate}
  \item Если в массиве 1 элемент --- завершиться.
  \item Найти середину массива.
  \item Посортировать первую половину.
  \item Посортировать вторую половину.
  \item Объединить массив.
\end{enumerate}

Алгоритм объединения массивов:
\begin{enumerate}
  \item Циклично проходим по двум массивам.
  \item В объединяемый ставим тот элемент, что меньше.
  \item Двигаемся дальше, пока не дойдем до конца обоих массивов.
\end{enumerate}

Time Complexity: $O(n\log n)$, Space Complexity: $O(n)$.


{\small На степике также упоминается \textbf{сортировка Шелла} и \textbf{пирамидальная сортировка}
(она же Heapsort или сортировка кучей), но их суть кратко описать довольно затруднительно.}

\section{Функции языка С для работы со строками}
\textbf{Строки} используются для представления текстовой информации.
В языке C строки рассматриваются как массивы символов (\verb|char|), заканчивающиеся
специальным зарезервированным символом с кодом 0.

% Также существуют (но реже используются) <<широкие>> строки, которые являются аналогичными
% массивами символов \verb|wchar_t|.

Прототипы функций для работы со строками в языке C находятся в заголовочном файле \verb|<string.h>|
(в языке C++ для работы с C-строками --- \verb|<cstring>|).

\verb|size_t strlen(const char *s)| - определяет длину строки \verb|s| без учёта нуль-символа.

\subsection*{Копирование строк}

\verb|char *strcpy(char *dst, const char *src)| --- выполняет побайтное копирование символов из строки \verb|src|
в строку \verb|dst|. Возвращает указатель \verb|dst|. Программист должен удостовериться, что \verb|dst| указывает
на участко памяти достаточного размера.

strncpy(s1,s2, n) - выполняет побайтное копирование n символов из строки  s2 в строку s1. возвращает значения s1
Конкатенация строк

\verb|char* strcat(char *dst, const char *src)| - объединяет строку \verb|src| со строкой \verb|dst|.
Результат сохраняется в \verb|dst|. 

strncat(s1,s2,n) - объединяет n символов строки s2 со строкой s1. Результат сохраняется в s1
\subsection*{Сравнение строк}

strcmp(s1,s2) - сравнивает строку s1 со строкой s2 и возвращает результат типа int:
0 –если строки эквивалентны, >0 – если s1<s2,  <0  — если s1>s2 С учётом регистра

strncmp(s1,s2,n) - сравнивает n символов строки s1 со строкой s2 и возвращает результат типа int:
0 –если строки эквивалентны, >0 – если s1<s2,  <0  — если s1>s2 С учётом регистра

stricmp(s1,s2) - сравнивает строку s1 со строкой s2 и возвращает результат типа int:
0 –если строки эквивалентны, >0 – если s1<s2,  <0  — если s1>s2 Без учёта регистра

strnicmp(s1,s2,n) - сравнивает n символов строки s1 со строкой s2 и возвращает результат типа int:
0 –если строки эквивалентны, >0 – если s1<s2,  <0 — если s1>s2 Без учёта регистра
\subsection*{Обработка символов}

isalnum(c) - возвращает значение true, если с является буквой или цифрой, и false в других случаях

isalpha(c) - возвращает значение true, если с является буквой,  и false в других случаях

isdigit(c) - возвращает значение true, если с является цифрой, и false в других случаях

islower(c) - возвращает значение true, если с является буквой нижнего регистра, и false в других случаях

isupper(c) - возвращает значение true, если с является буквой верхнего регистра, и false в других случаях

isspace(c) - возвращает значение true, если с является пробелом, и false в других случаях

toupper(c) - если символ с, является символом нижнего регистра, то функция возвращает преобразованный символ
с в верхнем регистре, иначе символ возвращается без изменений.
\subsection*{Функции поиска}

strchr(s,c) -  поиск первого вхождения символа с в строке s. В случае удачного поиска возвращает указатель
на место первого вхождения символа с. Если символ не найден, то возвращается ноль.

strcspn(s1,s2) - определяет длину начального сегмента строки s1, содержащего те символы, которые не входят в строку s2

strspn(s1,s2) - возвращает длину начального сегмента строки s1, содержащего только те символы, которые входят в строку s2

strprbk(s1,s2) - Возвращает указатель  первого вхождения любого символа строки s2 в строке s1

\subsection*{Функции преобразования}

atof(s1) - преобразует строку s1 в тип double

atoi(s1) - преобразует строку s1 в тип int

atol(s1) - преобразует строку s1 в тип long int
Функции стандартной библиотеки ввода/вывода <stdio>

getchar(с) - считывает символ с со стандартного потока ввода, возвращает символ в формате int

gets(s) - считывает поток символов со стандартного устройства ввода в строку s до тех пор, пока не будет нажата клавиша ENTER

\vspace{1cm}

Функции для работы с Си-строками никогда не выделяют память, если оказывается, что размер буфера недостаточен. Это 
может привести к неопределенному поведению и ощибкам сегментации. О выделении
достаточного размера памяти должен заботиться программист, который вызывает функцию.

\section{Методы языка С++ для работы со строками}

\section{Декларация структур (struct) в С/С++. Отличия в декларации}
\textbf{Структура} \label{def:struct} --- производный тип данных, который представляет какую-то определенную сущность.
Для определения структуры используется ключевое слово \verb|struct|:

\begin{verbatim}
struct ИмяСтруктуры {
  поля_структуры;
};
\end{verbatim}
Поля структуры --- это переменные, доступ к которым можно получать через объект структуры
с помощью оператора \verb|.| или через указатель на объект структуры через оператор \verb|->|.

В языке C, в отличие от C++, объявленная таким образом структура будет доступна под именем
\verb|struct ИмяСтруктуры| (в C++ --- просто \verb|ИмяСтруктуры|). Чтобы не писать слово
\verb|struct|, можно объявить псевдоним для типа структуры с помощью ключевого слова
\verb|typedef|. В C++ так тоже можно делать для обратной совместимости с Си. Как в C++, так
и в C для полей структур можно задавать значения по умолчанию.

{\small В языке C++ во всех структурах неявно объявляется конструктор и деструктор по умолчанию
(если они не объявлены явно). Коснтруктор вызывается при объявлении (и/или инициализации) объекта
структуры (также при вызове оператора \verb|new|, а деструктор --- когда объект покидает
область видимости или вызывается оператор \verb|delete|.)}

\begin{verbatim}
#include <iostream>
#include <cstdint>

struct Vector2 {
  float x;
  // Значение по умолчанию
  float y = 0;
};

typedef struct Vector2 vector2_t;

// typedef можно писать и сразу. Название структуры можно опускать
typedef struct {
  size_t size;
  char* str;
} string_t;

typedef struct Segment {
  Vector2 a;
  Vector2 b;
} segment_t;

int main() {
  // Обращение в стиле Си
  struct Vector2 a = {1.0, -3.0};
  vector2_t b = {1.0, 3.4};
  // Обращение в стиле C++
  Vector2 c = {-2.0, -0.4};

  // Анонимная структура. У нее нет названия,
  // но в остальном она работает как обычная структура.
  struct {
    double x;
    double y;
  } point = {.x = a.x, .y = a.y};
  // В строчке выше используется designated intializer,
  // который позволяет указывать названия полей, которые
  // инициализируются. (перед названием поля для этого)
  // ставится точка.
  // В Си это было с незапамятных времен, а в C++
  // стандартизировано лишь в C++20

  // Обращение к полю x
  std::cout << b.x + a.x + c.x << '\n';
  
  // Ипользование псевдонима и динамического выделения памяти
  segment_t *segment = new segment_t;
  // Обращение через указатель на структуру
  segment->a = a;
  segment->b = c;
  delete segment;
  return 0;
}
\end{verbatim}

\section{Инициализация и доступ к элементам структуры. Выравнивание}
Определение понятия структуры см. \hyperref[def:struct]{выше}.

\subsection*{Инициализация}

Инициализация струтруры в языках C и C++ отличается. Так, в языке C++
присутствует конструктор по умолчанию --- метод структуры, который неявно
вызывается компилятором при создании объекта структуры. Он же вызывается (но
уже фактически явно) и при выделении памяти с помощью оператора \verb|new|.
В языке C ничего подобного нет.

Конструктор по умолчанию в языке C++ инициализирует все поля значениями по
умолчанию, которые можно указывать явно. Если значения явно не указано, то
поля простых типов наподобие \verb|int| или указатели инициализируются нулями,
если структура располагается в статической памяти или в куче\footnote{при
выделении памяти с помощью оператора new. Особо искушенные последователи Культа
также знают о placement new, который может проинициализировать любой участок памяти (в
т.\,ч. выделенный с помощью malloc.)}
; и мусором, если
структура объявлена на стеке.
\begin{verbatim}
typedef struct {
  int a = 42;
  int c;
} ExampleStruct;

static ExampleStruct e1;

int main() {
  ExampleStruct e2;
  // 42 42
  std::cout << e1.a << ' ' << e2.a << '\n';
  // 0 <мусор>
  std::cout << e1.c << ' ' << e2.c << '\n';
}
\end{verbatim}

Для инициализации полей структур в Си используется перечисление значений
в порядке объявления полей. Также допустима инициализация с явным указанием
пар поле-значение:
\begin{verbatim}
typedef struct Example {
  int a;
  float f;
};

// Обычная инициализация
Example e1 = {0, 0.4};
// designated initializer
Example e2 = {.a = 0, .f = 0.4};
\end{verbatim}

Оба этих вида инициализации также поддерживаются языком Си (вторая --- начиная с C++11).
Кроме того, начиная с C++11 поддерживается еще один вид инициализации:
\begin{verbatim}
Example e3{0, 3.14};
\end{verbatim}

\subsection*{Выравнивание}
Обычно процессоры эффективнее рабтают, когда данные выравнены определенным образом.
Это значит, что их адрес должен иметь специфическое значение (обычно кратное
какой-либо степени числа 2). Отметим, что все простые типы должны быть выравнены
по своему размеру, то есть их адрес в памяти должен быть кратен размеру этого типа.
Так, адрес 4-байтного \verb|int| должен быть кратен числу 4, а адрес переменной типа
\verb|char| может быть любым.



Поэтому при создании структур компилятор может добавлять
неиспользуемые байты --- \textbf{паддинги}.

\section{Вложенные структуры и массивы структур}
Какой-то 

\section{Указатели на структуры}
Какой-то это бессмысленный вопрос. Тут даже не о чем говорить.

Вся общая теория указателей (\hyperref[sec:ptr_arithm]{арифметика указателей}, разыменования) также
применима к указателям на структуры. Для доступа к элементам структуры надо использовать
оператор \verb|->|.

Если стурктура объявлена на куче, то память также надо очищать вручную.
Также отметим

\section{Объединения и битовые поля}
\subsection*{Объединения}
\textbf{Объединение} --- группирование переменных, которые разделяют одну и ту же область памяти.

Объявление объединения (типа объединения или шаблона объединения) начинается с ключевого слова union.

\begin{verbatim}
union ИмяТипаОбъединения {
  Тип1 переменная_1;
  Тип2 переменная_2;
  ...
  ТипN переменная_n;
};
\end{verbatim}

Где
\textbf{ИмяТипаОбъединения} --- непосредственно имя новосозданного типа;

\textbf{переменная\_1, \dots, переменная\_n} --- имена переменных, которые являются полями объединения.
Эти переменные могут быть разных типов;

\textbf{Тип1, \dots, ТипN} --- типы полей объединения.

\paragraph{Размер объединения} равен размеру самого большого поля.

Объединение относится к определенному участку памяти, в котором может находиться объект одно из типов,
которые есть в объединении. При попытке перезаписать данные другим типом новые данные записываются
вместо старых, из-за чего старые данные не могут корректно удалиться. Поэтому в \verb|union| без
дополнительных плясок с бубном нельзя запихнуть <<умный>> тип наподобие \verb|std::string|.

При обращении к полю объединения записанные в память данные будут
интерпретироваться как данные того типа, к которому относится переменная, к которой происходит
обращение. Нетрудно догадаться, что обращение к неправильному типу может вызвать UB.

\begin{verbatim}
// Можно объявлять и анонимные union.
// Тогда их поля попадут в ту же область
// видимости, где и объявлено объединение.
union {
  float f;
  int i;
} united;
// Одно из возможных побитовых представлений NaN по IEE754.
united.i = 0x7f800001;
// nan (на x86_64 работает. как на других архитектурах, хз)
std::cout << united.f << '\n';
\end{verbatim}

Резюмируя:
\begin{enumerate}
  \item Объединения можно использовать для хранения одного из заданных типов данных. Чтобы знать,
  какой именно тип хранится в объединении, надо хранить эту информацию отдельно.
  \item Объединения можно использовать для побитового преобразования одного типа в другой
\end{enumerate}

{\small В C++ для более безопасного хранения нескольких типов в одном участке памяти можно использовать
\verb|std::variant|, а для побитовго преобразования (начиная с C++20) --- \verb|std::bit_cast|.}

\subsection*{Битовые поля}
\textbf{Битовое поля} позволяют задать длину поля структуры в битах. % получать доступ к конкретным битам структур.
То есть, они как бы позволяют получать целочисленные типы произвольной (но не
более машинного слова) длины. Битовые поля объявляются точно так же, как и обычные,
но после имени поля через двоеточие указывается его длина.
\begin{verbatim}
struct ИмяСтруктуры {
  unsigned <char|int|short|long|long long> имя_поля: длина;
};
\end{verbatim}

Обратите внимение, что только битовые поля могут иметь только целочисленные типы.
{\small Желательно, чтобы они были \verb|unsigned|. Хотя использование обычных (знаковых)
чисел не запрщается, оно, вообще говоря, может привести к неожиданным результатам (отрицательные числа) и даже к UB\textsuperscript{проверить?},
потому что способ представления отрицательных чисел до C++20 не был стандартизирован.
С C++20 все компиляторы обязаны использовать дополнительный код.}

Максимальное число, которое может поместиться в битовое поле длины $n$, равно $2^n - 1$.
Обычно, если несколько битовых полей (неважно каких типов) объявлены друг за другом, то
компилятор их ужимает так, чтобы они имели наименьший размер. При этом неиспользуемые в
битовых полях биты становятся недоступными и превращаются в паддинг (a.k.a. `struct offset').

В приведенном ниже примере (нумерация с нуля) биты 5, 6, 7 игнорируются и программа
выведет 31 и 255. Битовое поле \verb|c| позволяет получить доступ к первым пяти битам числа:
\begin{verbatim}
union {
  struct {
    unsigned char c: 5;
  } bitfield;
  unsigned char num;
};

// Все биты заполенены единицами
num = 255;
std::cout << (unsigned int) bitfield.c
          << ' ' << (unsigned int) num << '\n';
\end{verbatim}

% Использование битовых полей для выравнивания

\section{Локальные и глобальные переменные}

\section{Автоматические переменные}

\section{Внешние и статические переменные, особенности их реализации}
Чтобы было понятно, о чем идет речь, дадим несколько базовых определений:

\textbf{Единица трансляции} --- один файл исходных текстов C++ (имеет расширение \verb|cpp| или \verb|cc|).

\textbf{}

\section{Символические константы: \#define. Включение файла: \#include}
\paragraph{\#include} подставляет вместо себя содержимое указанного файла. Синтаксис:
\begin{verbatim}
  #include <файл>
\end{verbatim}
или
\begin{verbatim}
  #include "файл"
\end{verbatim}
Подключаемый файл может находиться либо в той же директории, в которой лежит и исходный файл,
либо в одном из системных путей (на Linux обычно \verb|/usr/include/| и \verb|/usr/include/c++/|).

При использовании синтаксиса с кавычками препроцессор сначала ищет файлы в той же директории,
где находится сам файл, и только потом --- в системных путях; а при использовании треугольных скобок --- наоборот.

{\small Можно добавить системные пути с помощью флага \verb|-I| (GCC, clang) или \verb|/I| (MSVC) компилятора. }

Руководство по стилю кода Google рекомендует использование \verb|<>| для подключения заголовков сторонних и стандартной
библиотек и \verb|""| для подключения заголовков текущего проекта.

Как правило, директива \verb|#include| для подключения заголовочных файлов, содержащих
объявления функций, структур, классов и т.\,д. Например, в заголовочном файле \verb|cmath|
стандартной библиотеки содержатся объявления математических функций \verb|std::sqrt|, \verb|std::sin|,
\verb|std::round| и других. В файле \verb|iostream| содержатся функции и структуры для ввода-вывода информации
в консоль.

\paragraph{\#define} позволяет определять символьные константы\footnote{для краткости я буду их называть макросами,
но гипотетически Вадим может к этому придраться}, вместо которых на этапе препроцессинга
будет подставляться указанное выражение.
Синтаксис таков:
\begin{verbatim}
  #define идентификатор выражение
  #define идентификатор(параметры, через, запятую) выражение
\end{verbatim}
где \verb|идентификатор| --- это имя макроса (любой валидный идентификатор),
а \verb|выражение| --- то, что будет подставляться вместо \verb|идентификатор|а.

В первом случае директива создает символическую константу (object-like macro),
вместо которой просто подставляется выражение.

Во втором случае директива создает функциональный макрос (function-like macro),
в которые можно передать несколько аргументов. Они будут подставлены в выражение
вместо параметров (см. пример). Поскольку в качестве аргумента макроса может
выступать любое выражение, которое подставляется в макрос прямым текстом, <<как есть>>,
параметры при использовании следует оборачивать в скобки, чтобы избежать неожиданных результатов
(ср. \verb|MUL| и \verb|CORRECT_MUL| в примере).

В выражении функционального макроса можно использовать два специальных оператора:
\verb|#параметр|, который оборачивает значение \verb|параметра| в кавычки,
превращая его в строковый литерал и \verb|#|, который позволяет сконкатенировать
параметр с чем угодно.

В \verb|выражении| можно использовать другие макросы, а в процедурные макросы можно передавать
другие макросы(в том числе и процедурные).

Отметим, что \verb|выражение| может быть пустым (в таком случае
вместо макроса подставится ничто). Также любой макрос можно впоследствии переопределить
с помощью директивы \verb|#define| либо разопределить с помощью директивы \verb|#undef|.
Тогда после разопределения макроса компилятор будет вести себя так, как будто этого
макроса никогда и не было; но в коде между \verb|#define| и \verb|#undef| этот макрос
будет доступен.

{\small В C++11 появилась возможность создавать макросы с переменным числом параметров.
Эта ужасно страшное колдунство. Подробнее смотри по ссылке:
\url{https://en.cppreference.com/w/cpp/preprocessor/replace}}

Пример:
\begin{verbatim}
#define QUESTION 52
#define ANSWER 42
#define SUM QUESTION + ANSWER
#define MERGE(x) v##x
#define MKSTRING(x) #x

#define MUL(x, y) x*y
#define CORRECT_MUL(x, y) (x) * (y)

int v42 = 24;
int vANSWER = -24;

// 10 94
std::cout << QUESTION - ANSWER << ' ' << SUM << '\n';
// 24 0
std::cout << MERGE(42) << ' ' << MERGE(42) + MERGE(ANSWER) << '\n';
// All human beings are born free and equal
std::cout << MKSTRING(All human beings are born free and equal) << '\n';
// 5 9
std::cout << MUL(3, 1 + 2) << ' ' << CORRECT_MUL(3, 1 + 2) << '\n';

#undef ANSWER
// Ошибка компиляции
std::cout << ANSWER << '\n';
\end{verbatim}


\section{Директивы препроцессора: \#if, \#ifdef, \#ifndef, \#else, \#endif}
Эти директивы препроцессора предназначены для условной компиляции, то есть они позволяют
включить или выключить компиляцию определенных участков кода. Директивы создают ветвления
на этапе препроцессора.

\paragraph{\#if} имеет следующий синтаксис:
\begin{verbatim}
#if <условие>
// скомпилировать код
#endif
\end{verbatim}
Подобно оператору(?) ветвления в C++, включает компиляцию нижеследующего
участка кода, если выполнено заданное условие. В условии можно использовать:
\begin{itemize}
  \item Числовые и символьные константы (\verb|42, 'Y'|)
  \item Арифметические, побитовые и логические операции
  \item Макросы
  \item Оператор \verb|defined(<макрос>)|. Если \verb|<макрос>| был ранее по тексту программы определен с помощью директивы препроцессора
  \verb|#define|, то оператор возвращает 1, иначе -- 0
  \item Идентификаторы, которые не являются ранее определенными макросами. Вместо них подставляется число 0.
\end{itemize}
Если при вычислении записанного в условии выражения получится 0, то оно считается ложным; если же выйдет любое ненулевое число --- истинным.

Следует отметить, что в директивах нельзя использовать оператор \verb|sizeof|, поскольку препроцессор ничегно не знает о типах.

Также существует директива препроцессора \verb|#elif|, которая является полным аналогом конструкции \verb|else if|.

\paragraph{\#ifdef, \#ifndef} имеют одинаковый синтаксис:
\begin{verbatim}
#ifdef <макрос>
// скомпилировать код
#endif

#ifndef <макрос>
// скомпилировать код
#endif
\end{verbatim}

Директива \verb|#ifdef| включает компиляцию участка кода, если \verb|<макрос>| был ранее определен с помощью директивы \verb|#defined|.

Директива \verb|#ifndef|, наоборот, включает компиляцию участка кода, если \verb|<макрос>| \textbf{не} был ранее определен
с помощью директивы \verb|#defined|.

{\small \textit{Примечание. Макросы можно разопределить с помощью директивы} \verb|#undef| }

\paragraph{\#else} может использоваться только в связке с вышеназванными директивами:
\begin{verbatim}
#ifndef <условие>
  // скомпилировать, если <условие> выполнено
#else
  // скомпилировать, если <условие> не выполнено
#endif
\end{verbatim}

Если оказывается, что условие директив \verb|#if, #ifdef, #ifndef| ложно, то все то, что находится между директивами \verb|#if|
и \verb|#else| игнорируется, а компилируется то, что находится между \verb|#else| и \verb|#endif|.

\paragraph{\#endif} обозначает конец ветвления.

Эти директивы можно использовать для определения операционной системы (проверка макросов \verb|__linux__|, \verb|__ANDROID__|,
\verb|_WIN32|, \verb|macintosh|),
различения C и C++ (макрос \verb|__cplusplus|).

Также Руководство по стилю кода Google рекомендует использовать эти директивы для предотвращения повторного включения одного
и того же файла (include guards):
\begin{verbatim}
#ifdef MY_FANCY_HEADER_H_
#define MY_FANCY_HEADER_H_ 1

int Sum(int a, int b);
int Odd(int a, int b);
typedef int(*FunctionPtr)(int, int);

#endif // MY_FANCY_HEADER_H_
\end{verbatim}

Более сложный и бесполезный пример:
\begin{verbatim}
#ifndef __cplusplus
#include <stdio.h>
void SayHi() {
  printf("Thou usest C!\n");
}
#elif __cplusplus >= 202300L
#include <print>
void SayHi() {
  std::print("Your C++ version is {}, supergood!\n",
             __cplusplus);
}
#else
#include <iostream>
void SayHi() {
  std::cout << "Your C++ version is "
            << __cplusplus << ", kinda old :(\n";
}
#endif

int main() {
  SayHi();
  return 0;
}
\end{verbatim}

\url{https://gcc.gnu.org/onlinedocs/cpp/If.html}

\url{https://sourceforge.net/p/predef/wiki/OperatingSystems/}

\section{Понятие алгоритма. Введение в алгоритмизацию}

\end{document}