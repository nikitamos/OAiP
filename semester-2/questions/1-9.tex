\section{Понятие сложности алгоритма, оценки времени исполнения}
\textbf{Сложность алгоритма} характеризует собой как быстро растут требуемые ресурсы
для работы алгоритма, а именно время выполнения или объём памяти, с
увеличением размера входных данных. Основное внимание уделяется временной сложности,
то есть оценке времени исполнения алгоритма от объёма входных данных.
Оценка сложности помогает понять, насколько эффективен алгоритм, особенно при работе
с большими объёмами данных.

Одним из самых важных инструментов для анализа сложности алгоритмов является Big $O$ Notation ($O$ - большое),
которое позволяет оценить верхнюю границу времени выполнения алгоритма в худшем случае.
Простыми словами, Big $O$ показывает как будет меняться производительность алгоритма с зависимости
от роста входящих данных.

Если мы будем увеличивать количество входящих данных, то у нас может расти количество операций и время за
которое выполнится алгоритм. Так же может расти количество памяти используемой данным алгоритмом для обработки
входного объема данных. Big $O$ будет показывать скорость роста времени
исполнения алгоритма.

Big $O$ называется так из-за того, что в математике <<$O$>> используется для обозначения ''order of'' (порядка) и позволяет сравнивать функции роста.
Он представляет собой математическую нотацию, которая описывает, как алгоритм будет выполняться в наихудшем случае, исходя из размера входных данных.

Примеры нотации Big $O$
\begin{enumerate}
    \item $O(1)$ --- константная сложность. Время выполнения алгоритма не зависит от размера входных данных.
          Например, доступ к элементу массива по индексу.
    \item $O(\log{n})$ --- логарифмическая сложность. Время выполнения алгоритма растет
          медленно с увеличением размера входных данных. Например, бинарный поиск в отсортированном массиве.
    \item $O(n)$ --- линейная сложность. Время выполнения алгоритма пропорционально размеру входных данных.
          Например, просмотр всех элементов в массиве.
    \item $O(n\log{n})$ --- линейно-логарифмическая сложность. Время выполнения алгоритма растет быстрее,
          чем линейно, но медленнее, чем квадратично. Например, сортировка слиянием (merge sort).
    \item $O(n^2)$ --- квадратичная сложность. Время выполнения алгоритма зависит от квадрата размера входных данных. Например, сортировка пузырьком (bubble sort).
    \item $O(n^3)$ --- кубическая сложность. Время выполнения алгоритма зависит от размера входных данных в кубе. Например, алгоритмы, которые имеют три вложенных цикла, такие как некоторые методы многомерной обработки данных.
    \item $O(2^n)$ --- экспоненциальная сложность. Время выполнения алгоритма 
          увеличивается экспоненциально по мере увеличения размера входных данных. 
          Это часто встречается в алгоритмах, которые решают проблемы методом 
          <<разделяй и властвуй>> или используют рекурсию без оптимизации. Примером 
          алгоритма с экспоненциальной сложностью может служить рекурсивное 
          вычисление чисел Фибоначчи.
    \item $O(n!)$ --- факториальная сложность. Это самая высокая степень 
          роста времени выполнения алгоритма. Время выполнения алгоритма растет 
          факториально от размера входных данных. Этот тип сложности встречается, 
          например, при переборе всех возможных комбинаций элементов, что делает 
          его чрезвычайно неэффективным для больших значений n. Пример алгоритма с 
          факториальной сложностью может быть перебор всех перестановок элементов 
          массива.
\end{enumerate}

\subsection{Отбрасывание констант}
Пусть у нас есть алгоритм с временем выполнения $5n^2 + 3n + 2$.

При оценке сложности по большому $O$ отбрасываем константы и оставляем 
наиболее влиятельное слагаемое относительно размера входных данных, то есть $O(n^2)$.
Важно понимать, что при увеличении $n$, константы и менее 
влиятельные слагаемые ($3n$, $2$) становятся менее значимыми.

\subsection{Отбрасывание несущественной части}
Рассмотрим алгоритм с временем выполнения $O(n^2 + n + \log{n})$.

При оценке сложности по большому $O$ отбрасываем менее влиятельные части и 
константы, оставляя самую значимую величину относительно размера входных 
данных, что приводит к $O(n^2)$.

Использование такой асимптотической нотации позволяет увидеть, как алгоритм 
будет масштабироваться с ростом входных данных, игнорируя детали, не имеющие 
существенного влияния на его эффективность.

На практике это позволяет более удобно сравнивать алгоритмы и предсказывать 
их поведение при изменении размеров данных без учета точных числовых значений 
или мелких частей выражений, которые несущественны для скорости роста времени 
выполнения при увеличении $n$.

\section{Общая классификация вычислительных алгоритмов}
% Наиболее простым видом алгоритма является линейный алгоритм, при котором 
% действия выполняются последовательно, одно за другим, без разветвлений и 
% возвратов. Пример: вычисления любой формулы.

% В процессе решения многих задач часто возникает необходимость в зависимости 
% от исходных данных или промежуточных результатов проводить вычисления либо по 
% одним, либо по другим формулам, т.е. по разным направлениям -- ветвям. Такой 
% вычислительный алгоритм называется разветвляющимся. Пример: нахождение корней 
% квадратного уравнения.

% При решении большинства практических задач возникает необходимость 
% неоднократного повторения однотипных действий при различных значениях 
% параметров, определяющих эти действия. Такие алгоритмы называют циклическими, 
% а повторяемые участки вычислений -- циклами. Пример -- вычисление факториала 
% натурального числа.

Алгоритмы можно классифицировать по различным критериям, включая их вычислительную сложность, парадигму проектирования, область применения и особенности реализации. Рассмотрим основные подходы к классификации алгоритмов.

По \textit{типу решаемых задач} алгоритмы делятся на несколько крупных категорий. 
Алгоритмы сортировки предназначены для упорядочивания данных и включают такие 
методы как пузырьковая сортировка ($O(n^2)$), быстрая сортировка ($O(n \log{n})$) и 
сортировка подсчетом ($O(n)$). Алгоритмы поиска решают задачу нахождения 
элементов в структурах данных, например, линейный поиск ($O(n)$) и бинарный 
поиск ($O(\log n)$). Алгоритмы на графах работают с сетями и связями, включая 
алгоритмы Дейкстры для поиска кратчайшего пути или алгоритмы обхода в глубину 
и ширину.

По \textit{вычислительной сложности} алгоритмы классифицируются с использованием Big $O$ 
нотации. Алгоритмы с постоянным временем $O(1)$ выполняются за фиксированное 
время независимо от входных данных. Линейные алгоритмы $O(n)$ увеличивают время 
выполнения пропорционально размеру данных. Более сложные алгоритмы включают 
квадратичные $O(n^2)$, логарифмические $O(\log{n})$, линейно-логарифмические $O(n \log{n})$,
экспоненциальные $O(2^n)$ и факториальные $O(n!)$ алгоритмы.

По \textit{парадигмам проектирования} выделяют несколько подходов. Жадные 
алгоритмы делают локально оптимальный выбор на каждом шаге. <<Разделяй и 
властвуй>> разбивают задачу на подзадачи (например, быстрая сортировка). 
Динамическое программирование решает задачи путем запоминания промежуточных 
результатов. Алгоритмы методом ветвей и границ оптимизируют полный перебор.

По \textit{области применения} алгоритмы делятся на численные (вычисления и 
оптимизация), строковые (обработка текста), криптографические (шифрование), 
графические (обработка изображений), алгоритмы машинного обучения и другие 
специализированные категории.

По \textit{особенностям реализации} различают рекурсивные и итеративные 
алгоритмы, детерминированные и вероятностные, точные и приближенные, 
устойчивые и неустойчивые (для численных методов), последовательные и 
параллельные алгоритмы.

\section{Точность представления чисел}
Вещественные числа обычно представляются в виде чисел с плавающей запятой. 
\textbf{Числа с плавающей запятой} --- один из возможных способов представления 
действительных чисел, который является компромиссом между точностью и 
диапазоном принимаемых значений, его можно считать аналогом экспоненциальной 
записи чисел, но только в памяти компьютера.

Число с плавающей запятой состоит из набора отдельных двоичных разрядов, 
условно разделенных на так называемые \textit{знак} (англ. sign), \textit{порядок} (англ. exponent)
и \textit{мантиссу} (англ. mantissa). В наиболее 
распространённом формате (стандарт \href{https://en.wikipedia.org/wiki/IEEE_754}{IEEE 754})
 число с плавающей запятой представляется в виде набора 
битов, часть из которых кодирует собой мантиссу числа, другая часть -- 
показатель степени, и ещё один бит используется для указания знака числа ($0$ 
-- если число положительное, $1$ -- если число отрицательное). При этом 
порядок записывается как целое число в коде со сдвигом, а мантисса -- в 
нормализованном виде, своей дробной частью в двоичной системе счисления.

Порядок также иногда называют экспонентой или просто показателем степени.

При этом лишь некоторые из вещественных чисел могут быть представлены в 
памяти компьютера точным значением, в то время как остальные числа 
представляются приближёнными значениями.

Более простым вариантом представления вещественных чисел является вариант \textit{с фиксированной точкой}, когда целая и вещественная части хранятся отдельно. Например, на целую 
часть отводится всегда $X$ бит и на дробную отводится всегда $Y$ бит. Такой способ в архитектурах процессоров не присутствует. Отдаётся предпочтение числам с плавающей запятой, 
как компромиссу между диапазоном допустимых значений и точностью.

\subsection{Типы чисел с плавающей точкой}

Точность представления чисел в вычислительных системах является критически важным аспектом, определяющим корректность математических вычислений. При работе с числовыми 
данными компьютеры используют два принципиально разных способа представления: для целых и для вещественных чисел, каждый из которых имеет свои особенности и ограничения в 
плане точности.

Целые числа в компьютерных системах представляются абсолютно точно в пределах своего диапазона, что достигается благодаря использованию фиксированного формата хранения. 
Современные процессоры поддерживают работу с 8-битными, 16-битными, 32-битными и 64-битными целыми числами, как знаковыми, так и беззнаковыми. Например, 32-битное 
беззнаковое целое может хранить значения от 0 до 4 294 967 295, а его знаковый аналог -- от -2 147 483 648 до +2 147 483 647. Однако главная проблема целочисленного 
представления -- это ограниченный диапазон и возможность переполнения, когда результат операции выходит за допустимые границы, приводя к некорректным значениям.

Совершенно иная ситуация складывается с вещественными числами, которые в компьютерах представляются в формате с плавающей запятой (стандарт IEEE 754). Этот формат, хотя и 
позволяет работать с очень большим диапазоном значений (от $10^{-308}$ до $10^{308}$ для 64-битного \mverb{double}), неизбежно приводит к потере точности из-за особенностей 
двоичного представления десятичных дробей. Например, такое число как 0.1 не может быть точно представлено в двоичной системе счисления, что вызывает накопление 
погрешностей при последовательных вычислениях. Типичная точность составляет около 7 значащих цифр для 32-битного
\mverb{float} и около 15-16 цифр для 64-битного \mverb{double}.
\begin{enumerate}
    \item \textbf{Число одинарной точности} (\mverb{float}) --- компьютерный формат представления чисел, занимающий в памяти 32 бита или 
          4 байта. Используется для работы с вещественными числами везде, где не нужна очень высокая точность.
    \item \textbf{Число двойной точности} (\mverb{double}) --- компьютерный формат представления чисел, занимающий в памяти 64 бита или 8 байт.
          Часто используется благодаря своей неплохой точности, даже несмотря на двойной расход памяти и сетевого трафика относительно чисел одинарной точности.
    \item \textbf{Число четверной точности} (\mverb{long double} в некоторых реализациях) --- компьютерный формат представления чисел, занимающий в памяти 
          128 бит или 16 байт. Используется в случае необходимости крайне высокой точности.
\end{enumerate}


\section{Строковый тип в C++. Представление в памяти.\\ Автоматическое управление памятью для Си строк\\ и std::string}
В языке C++ работа со строками может осуществляться двумя принципиально разными способами: с использованием классических C-строк и через класс \mverb{std::string} из 
стандартной библиотеки. C-строки представляют собой массивы символов типа char, которые обязательно завершаются нуль-терминатором (`\verb|\0|'). Такое представление унаследовано из 
языка C и хранится в памяти как последовательность байт с явным указателем на начало строки. Основная проблема C-строк заключается в необходимости ручного управления памятью
~-- разработчик должен самостоятельно выделять достаточный объем памяти под строку, следить за переполнением буфера и освобождать ресурсы. Это не только неудобно, но и 
потенциально опасно, так как ошибки в работе с памятью могут приводить к уязвимостям безопасности.

В отличие от этого, класс \mverb{std::string} предоставляет современный и безопасный способ работы со строками. Внутри он использует динамически выделяемую память, 
автоматически расширяя буфер при необходимости. Объект \mverb{std::string} хранит не только сами символьные данные, но и дополнительную служебную информацию -- текущий 
размер строки и емкость выделенного буфера. Это позволяет эффективно управлять памятью и избегать частых перераспределений. Важнейшее преимущество \mverb{std::string} -- 
автоматическое освобождение памяти при выходе объекта из области видимости.

С точки зрения удобства работы \mverb{std::string} также значительно превосходит C-строки. Стандартная библиотека предоставляет богатый набор методов для манипуляции 
строками: поиск подстрок, вставка и удаление символов, конкатенация через оператор \verb|+| и многое другое. При этом все операции безопасны с точки зрения работы с памятью. 
В современных проектах на C++ рекомендуется повсеместно использовать \mverb{std::string}, оставляя C-строки только для случаев, когда требуется совместимость с 
унаследованным кодом или внешними C-библиотеками. Переход на \mverb{std::string} позволяет писать более надежный, читаемый и поддерживаемый код, избавляя разработчика от 
многих потенциальных ошибок, связанных с ручным управлением памятью.

Важно отметить, что \mverb{std::string} не является абсолютно идеальным решением для всех случаев. В высокопроизводительных системах, где критически важна скорость работы и 
минимальные накладные расходы, иногда предпочтительнее использовать более низкоуровневые подходы. Однако для подавляющего большинства приложений преимущества \mverb{std::string}
-- автоматическое управление памятью, безопасность и удобство интерфейса -- с лихвой перевешивают возможные микрооптимизации, которые можно получить при работе с C-строками.


\section{Файлы. Двоичное и текстовое представление файлов. Стандартные файлы}
\textbf{Файл}~--- именованный объект, хранящий данные на каком-либо носителе (дискета, винчестер, СD). Файл, как и массив,~--- это совокупность данных, потому они немного похожи. Существенные отличия:
\begin{enumerate}
    \item Файлы в отличие от массивов располагаются не в оперативной памяти, а на жестких дисках или на внешних носителях, хотя файл может располагаться на так называемом электронном диске (в оперативной памяти).
    \item Файл не имеет фиксированной длины, т.е. может увеличиваться и уменьшаться.
    \item Перед работой с файлом его необходимо открыть, а после работы – закрыть\footnotemark.
\end{enumerate}

\footnotetext{Говоря о файлах нельзя не сказать о файловой системе. \textit{Файловая система}~--- это совокупность файлов и управляющей информации на диске для доступа к файлам. Или по-другому -- это совокупность программных средств для доступа к файлам. Существует довольно много файловых систем, например, MS-DOS.

В файловой системе МS-DOS имена файлов состоят из двух частей, разделенных точкой: имя файла и расширение. Поле расширения может содержать не более трех символов. Расширение 
обычно указывает на тип хранимой информации или на структуру файла, может вообще отсутствовать. Примеры наиболее распространенных расширений:
\texttt{exe}, \texttt{com}, \texttt{bat}, \texttt{txt}, \texttt{doc}, \texttt{mp3}, \texttt{htm} и др.}

Файлы хранятся в каталогах (директориях). Допускаются вложенные каталоги (подкаталоги/поддиректории).

Различают два вида файлов: \textit{текстовые} и \textit{бинарные}.

\subsection{Виды файлов}
\textbf{Текстовый файл}~--- компьютерный файл, содержащий текстовые данные, как правило, организованные в виде строк.

Текстовые файлы могут быть просмотрены и отредактированы с клавиатуры любым текстовым редактором и имеют очень простую структуру: последовательность ASCII-символов. Примеры 
известных текстовых файлов: \verb|*.bat|, \verb|*.c|, \verb|*.asm|.

Текстовый файл может содержать как форматированный (шрифт, начертание, размер и т.п), так и неформатированный текст. В MS-DOS и Microsoft Windows для файлов с 
неформатированным текстом обычно используется расширение \verb|txt|. Тем не менее, текстовыми могут являться файлы с любым другим расширением или без оного. Например, 
исходные коды программ обычно хранятся в файлах с расширениями, соответствующими языку программирования, на котором написаны программы \verb|.bas|, \verb|.pas|, \verb|.c|
~--- это тоже текстовые файлы. Форматированный текс (текст с разметкой) хранится в файлах с расширением \verb|.rtf|, \verb|.htm|, \verb|.html|.

Текстовым файлам противопоставляются \textit{двоичные файлы}, в которых содержатся данные, не рассчитанные на интерпретацию в качестве текса
(например, файлы, хранящие закодированные звук или изображение).

\textbf{Двоичный (бинарный) файл}~--- в широком смысле: последовательность произвольных байт. Двоичные файлы применяются для хранения нетекстовой информации: 
изображений (\verb|.bmp|, \verb|.jpg|), исполняемых файлов (\verb|.exe|) и др. Но можно привести в качестве примера формат \verb|.doc|, который используется для хранения текстовой информации. Двоичные 
файлы хранят информацию почти в том виде, в котором она представляется в памяти компьютера во время работы программы. Поэтому при чтении такого файла практически не 
выполняется никаких преобразований, что ускоряет процесс чтения. Самый большой недостаток двоичных файлов -- их непереносимость.

% GPT moment????
% Файлы делятся на текстовые и нетекстовые (последние иногда называют двоичными, или бинарными). Файл, содержащий программу на Си, - текстовый; файл, который вы можете 
% создать, используя, например, встроенный редактор Norton Commander – тоже текстовый. А вот файл, содержащий, например, рисунок в формате JPEG (да и в любом другом 
% графическом формате), - двоичный.
Текстовые файлы отличаются от двоичных двумя особенностями
\begin{itemize}
    \item во-первых, они делятся на строки, каждая из которых заканчивается переводом 
          строки, состоящим из двух символов с кодами \mverb{0х0D 0х0А};
    \item во-вторых, текстовые файлы заканчиваются <<признаком конца файла>> - символом с кодом \mverb{0х1А} (точнее, должны 
          заканчиваться, это условие соблюдается не всегда).
\end{itemize}

При чтении текстового файла (потока) функции С преобразуют <<признак конца строки>>, т.е. последовательность символов \mverb{0х0D 0х0А}, в один символ \mverb{0х0А}
(`\verb|\n|'), а <<признак конца файла (потока)>> -- в значение ЕОF (End Of File). Константа EOF определена в заголовочном файле \mverb{stdio.h} и обычно равна $-1$.

При чтении двоичных потоков никаких преобразований не происходит.

То, с каким потоком мы собираемся работать --- текстовым или двоичным, указывается при его открытии. Один из способов открытия потока -- использование функции \verb|fopen|. Тип потока указывается в строке параметров, которая является вторым аргументом этой функции. Пример:
\begin{listing}[H]
    \renewcommand{\listingscaption}{Листинг}
    \begin{minted}{C}
        f = fopen("test.ext", "rt");
    \end{minted}
    \caption{Открытие текстового файла test.ext для чтения и связывания его с файловой переменной f.}
\end{listing}

На то, что файл открывается как текстовый, указывает буква `\verb|t|' в строке ``\verb|rt|''. Чтобы открыть этот файл как бинарный, надо использовать букву `\verb|b|':
\begin{minted}{C}
    f = fopen("test.ext", "rb");
\end{minted}

\subsection{Стандартные файлы (потоки)}
\textbf{Поток} -- байтовая последовательность, передаваемая в процессе ввода-вывода.

Поток должен быть связан с каким-либо устройством или файлом на диске. В терминологии С это звучит так: поток должен быть направлен на какое-то устройство или файл. Любой 
файл рассматривается как байтовая последовательность:
\begin{center}
    <байт0><байт1><байт2>$\dots$<EOF>
\end{center}

EOF является стандартной константой -- признаком конца файла.

Существуют стандартные потоки и потоки, объявляемые в программе. Последние обычно связываются с файлами на диске, создаваемыми программистом. Стандартные потоки назначаются 
и открываются системой автоматически. С началом работы любой программы открываются 5 стандартных потоков, из которых основными являются следующие:
\begin{itemize}
    \item \verb|stdin|~--- поток стандартного ввода (обычно связан с клавиатурой);
    \item \verb|stdout|~--- поток стандартного вывода (обычно связан с терминалом);
    \item \verb|stderr|~--- вывод сообщений об ошибках (связан с терминалом).
\end{itemize}

Кроме этого, открывается поток стандартной печати и дополнительный поток для последовательного порта.

Пример, демонстрирующий наличие стандартного потока вывода \verb|stdout|. Ряд функций вывода (например, \verb|printf|) всегда работает именно со стандартным устройством вывода. Для работы с потоками, отличными от стандартных, имеются другие функции. В данном случае мы все равно используем стандартный поток, но задать его хотим не <<по умолчанию>>, а явно. Поэтому вместо \verb|printf| надо использовать функцию \verb|fprintf|, первым параметром которой является поток.
\begin{minted}{C}
#include <stdio.h>

int main(void) {
    fprintf(stdout, "Привет, Мир!");
    return 0;
}
\end{minted}

\section{Понятие потока. Открытие и закрытие файлов. Операции ввода- вывода. Указатель чтения-записи в файле}
\subsection{Поток}
\textbf{Поток} --- байтовая последовательность, передаваемая в процессе ввода-вывода.
Поток должен быть связан с каким-либо устройством или файлом на диске. В терминологии Си это звучит так:
поток должен быть направлен на какое-то устройство или файл. Любой файл рассматривается как байтовая последовательность.

Система ввода/вывода языка Си поддерживает интерфейс, не зависящий от того, какое в действительности используется физическое
устройство ввода/вывода, то есть абстрактный уровень между программистом и физическим устройством. Эта абстракция и называется
потоком. Способ же хранения информации на физическом устройстве называется файлом.

Несмотря на то, что устройства очень разные (терминал, дисководы, магнитная лента и др.), стандарт ANSI языка Си связывает каждое
из устройств с логическим устройством, называемым потоком. Так как потоки не зависят от физических устройств, то одна и та же функция
может записывать информацию на диск, на магнитную ленту или выводить ее на экран.

В языке Си существует два типа потоков: текстовый (text) и двоичный (binary).

\textbf{Текстовый поток}~--- это последовательность символов. Однако, символы, которые передаются в поток и выводятся на экран не всегда
взаимно однозначно соответствуют друг другу. Некоторые символы, например, возврат каретки или символ табуляции присутствуют в
файле, но на экране как бы теряются.

\textbf{Двоичный поток} – это последовательность байтов, которые взаимно однозначно соответствуют тому, что находится на внешнем устройстве.

Поток может быть связан с файлом с помощью оператора открытия файла. Как только файл открыт, то информация может передаваться между ним и Вашей программой.

Не все файлы одинаковы. К примеру, из файла на диске Вы можете выбрать 5-ую запись или заменить 10-ую запись.
В то же время в файл, связанный с печатающим устройством, информация может передаваться только последовательно
в том же порядке. Это иллюстрирует самое главное различие между потоками и файлами: все потоки одинаковы, что нельзя сказать о файлах.

Операция открытий файла связывает поток с определенным файлом. Операция закрытия файла разрывает эту связь. Если поток был открыт для
вывода, то при выполнении операции закрытия файла соответствующий буфер памяти записывается на внешнее устройство. Если программа закончила
работу нормально, то все файлы автоматически закрываются.

Каждый поток, связанный с файлом, имеет управляющую структуру, называемую FILE. Она описана в заголовочном файле \mverb{stdio.h}.

В файловой системе языка Си в начале выполнения каждой программы автоматически открываются 5 предопределенных потоков.
Три из ник относятся к стандартным потокам: \mverb{stdin} – стандартный поток ввода, \mverb{stdout} – стандартный поток
вывода, \mverb{stderr} – стандартный поток ошибок. Обычно эти потоки направляются к консоли (как известно, консоль~--- это
клавиатура+дисплей). Но можно перенаправлять их на другое устройство, в тех операционных системах, которые поддерживают
перенаправление. Перенаправление ввода/вывода поддерживаются такими операционными системами, как Windows, DOS, UNIX, OS/2.

\subsection{Открытие и закрытие файлов}
Прежде чем читать или записывать информацию в файл, он должен быть открыт и тем самым связан с потоком. Это можно сделать
с помощью библиотечной функции \mverb{fopen()}. Она берет внешнее представление файла (например: \verb|c:\\my_prog.txt|) и связывает его
с внутренним логическим именем, которое используется далее в программе. Логическое имя~---– это указатель на требуемый файл.
Его необходимо определить; делается это, например, так:
\begin{minted}{C++}
FILE *fp;
\end{minted}
Здесь \mverb{FILE} – имя типа, описанное в стандартном заголовочном файле \mverb{stdio.h}, \verb|fp| --- указатель на файл.
Обращение к функции \mverb{fopen()} в программе осуществляется выражением:
\begin{minted}{C++}
fp = fopen(спецификация файла, "способ использования файла");
\end{minted}

Спецификация файла (т.е. имя файла и путь к нему) может, например, иметь вид: \verb|c:\my_prog.txt| – для файла \verb|my_prog.txt| на диске с:.

Если в результате обращения к функции \mverb{fopen()} возникает ошибка, то она возвращает константу \mverb{NULL}.

Работа с дисковым файлом начинается с объявления указателя на поток. Формат такого объявления:
\begin{minted}{C++}
FILE*имя указателя.
\end{minted}

Слово \mverb{FILE} является стандартным именем структурного типа, объявленного в заголовочном файле \verb|stdio.h|.
В структуре \mverb{FILE} содержится информация, с помощью которой ведется работа с потоком, в частности: указатель
на буфер, указатель (индикатор) текущей позиции в потоке и т.д.

Следующий шаг --- открытие потока, которое производится с помощью стандартной функции \mverb{fopen()}. Эта функция
возвращает конкретное значение для указателя на поток и поэтому ее значение присваивается объявленному ранее указателю.
Соответствующий оператор имеет формат:
\begin{minted}{C++}
имя_указателя = fopen(имя_файла, режим_открытия);
\end{minted}

Параметры функции \mverb{fopen()} являются строками, которые могут быть как константами, так и указателями на символьные массивы. Например:

\begin{minted}{C++}
fp = fopen("test.dat", "r");
\end{minted}

Здесь \verb|test.dat| – это имя физического файла в текущем каталоге диска, с которым теперь будет связан поток с указателем \verb|fp|.
Параметр режима \verb|r| означает, что файл открыт для чтения. Что касается терминологии, то допустимо употреблять как выражение
<<открытие потока>>, так и выражение «открытие файла".

Надо хорошо понимать, что открытие уже существующего файла для записи ведет к потере прежней информации в нем. Если такой файл еще
не существует, то он создается. Открывать для чтения можно только существующий файл.

После работы с файлом он должен быть закрыт функцией \mverb{fclose()}. В процессе завершения программы незакрытые файлы автоматически закрываются системой.

\subsection{Позиционирование}
Любой файл, каким бы он ни был и как бы не обрабатывался, представляет собой просто последовательность байтов, файловый
указатель в каждый момент времени указывает на некоторый байт файла, начиная с которого будет выполняться следующая
операция. Любая операция с файлом каким-то образом изменяет положение файлового указателя. Например, при открытии файла
для чтения (\verb|r|) файловый указатель устанавливается на первый байт файла (более точно – файловый указатель, являющийся
обычной длинной переменной, принимает значение 0). То же самое происходит и при открытии файла для записи (\verb|w|), только
в этом случае старое содержимое файла (если оно было) теряется. А вот при открытии файла для дозаписи (\verb|a|) файловый
указатель устанавливается на конец файла. При чтении данных из файла указатель сдвигается вперед на количество байт, которое
занимают прочитанные данные. При записи в файл – тоже вперед на количество байт, которое занимают записанные данные.

Каждый открытый файл имеет так называемый указатель на текущую позицию в файле. Все операции над файлами (чтение и запись)
работают с данными данной позиции. При каждом выполнении функции чтения или записи указатель смещается на количество прочитанных
или записанных байт, т.е. устанавливается сразу за прочитанным или записанным блоком данных в файле. В этом случае осуществляется
так называемый последовательный доступ к данным, который очень удобен, когда нам необходимо последовательно работать с данными в файле.


\section{Проверка операций ввода-вывода. Пример}
\subsection{Для языка C}
При работе с файлами и потоками в языке Си обязательно необходимо проверять успешность операций ввода-вывода. Это позволяет своевременно
обнаружить ошибки и корректно их обработать.

\subsubsection{Проверка открытия файла}
Функция \mverb{fopen()} возвращает указатель на поток или \mverb{NULL} в случае ошибки (например, если файл не существует при открытии для чтения):

\begin{minted}{C++}
FILE *fp = fopen("file.txt", "r");
if (fp == NULL) {
  perror("Ошибка открытия файла");
  // Обработка ошибки
}
\end{minted}

\subsubsection{Проверка операций чтения и записи}
Функции чтения (\mverb{getc()}, f\mverb{read()} и др.) при достижении конца файла возвращают специальные значения (\mverb{EOF}
или количество прочитанных элементов меньше ожидаемого).

Функции записи (\mverb{putc()}, \mverb{fwrite()} и др.) могут возвращать значения, отличные от количества записанных элементов или \mverb{EOF}, что говорит об ошибке.
Пример проверки чтения символа:

\begin{minted}{C}
int ch = getc(fp);
if (ch == EOF) {
  if (feof(fp)) {
    // Конец файла
  } else if (ferror(fp)) {
    perror("Ошибка чтения файла");
  }
}
\end{minted}

\subsubsection{Проверка указателя файла после операций позиционирования}
Функция \mverb{fseek()} возвращает 0 при успешном выполнении, иначе ненулевое значение:
\begin{minted}{C}
if (fseek(fp, 0, SEEK_SET) != 0) {
  perror("Ошибка позиционирования в файле");
}
\end{minted}

\subsubsection{Проверка закрытия файла}
Функция \mverb{fclose()} возвращает 0 при успешном закрытии, и \verb|EOF| при ошибке:
\begin{minted}{C}
if (fclose(fp) != 0) {
  perror("Ошибка закрытия файла");
}
\end{minted}

\subsection{Для языка C++:}
В языке C++ для работы с файлами и потоками используется библиотека \mverb{<fstream>}, включающая классы \mverb{ifstream}
(ввод из файла), \mverb{ofstream} (вывод в файл) и \mverb{fstream} (и ввод, и вывод).

\subsubsection{Проверка открытия файла}
При создании объекта потока файла или вызове метода \mverb{open()} поток можно проверить с помощью движения логического
значения, метода \mverb{is_open()} или проверки состояния потока:
\begin{minted}{C++}
std::ifstream file("file.txt");
if (!file.is_open()) {
  std::cerr << "Ошибка открытия файла\n";
  // Обработка ошибки
}

// ИЛИ

std::ifstream file;
file.open("file.txt");
if (!file) {
  std::cerr << "Ошибка открытия файла\n";
}
\end{minted}

\subsubsection{Проверка состояния потока после операций}
Потоки в C++ имеют методы и операторы для проверки состояния:
\begin{itemize}
\item \mverb{good()} — поток в хорошем состоянии (нет ошибок и не \verb|EOF|)
\item \mverb{eof()} — достигнут конец файла
\item \mverb{fail()} — произошла ошибка операции ввода-вывода
\item \mverb{bad()} — серьёзная ошибка (например, сбой устройства)
\item \mverb{operator bool()} — поток готов к работе (эквивалентно \mverb{!fail()})
\end{itemize}
Пример чтения с проверкой:

\begin{minted}{C++}
char ch;
if (file.get(ch)) {
  // Символ успешно прочитан
} else if (file.eof()) {
  // Конец файла
} else if (file.fail()) {
  std::cerr << "Ошибка чтения файла\n";
}
\end{minted}
\subsubsection{Проверка записи}
Запись в файл через \mverb{ofstream} или \mverb{fstream} обычно проверяется состоянием потока:
\begin{minted}{C++}
std::ofstream out("output.txt");
out << "Пример текста";
if (!out) {
  std::cerr << "Ошибка записи файла\n";
}
\end{minted}

\subsection{Закрытие файла}
В C++ закрытие файла происходит автоматически при разрушении объекта потока. Если требуется
закрыть явно, используется метод \mverb{close()}.
Рекомендуется проверить состояние после закрытия:
\begin{minted}{C++}
file.close();
if (file.fail()) {
  std::cerr << "Ошибка закрытия файла\n";
}
\end{minted}

\section{Функции для модификации содержимого файла: futc, getc, feof, fputs, fgets, fprintf, fscanf, rewind}
Основные функции стандартной библиотеки C, применяемые для чтения, записи и управления положением указателя в файле:

\begin{minted}{C++}
int putc(int c, FILE *fp);
\end{minted}
Записывает символ c в файл, связанный с потоком \mverb{fp}. Возвращает записанный символ при успехе или \mverb{EOF} при ошибке.

\begin{minted}{C++}
int fgetc(FILE *fp);
\end{minted}
Читает символ из файла \mverb{fp}. Возвращает прочитанный символ или \mverb{EOF}, если достигнут конец файла или произошла ошибка.

\begin{minted}{C++}
int feof(FILE *fp);
\end{minted}
Проверяет, достигнут ли конец файла, связанного с потоком \mverb{fp}. Возвращает ненулевое значение, если конец файла достигнут, и 0, если нет.

\begin{minted}{C++}
int fputs(const char *str, FILE *fp);
\end{minted}
Записывает строку \mverb{str} в файл \mverb{fp}. Возвращает ненулевое значение при ошибке записи, иначе — положительное значение.

\begin{minted}{C++}
char *fgets(char *str, int n, FILE *fp);
\end{minted}
Читает строку из файла \mverb{fp} в буфер \mverb{str} длиной не более $n-1$ символов. Чтение заканчивается при достижении новой строки или конца файла. Возвращает \mverb{str} при успехе или \mverb{NULL} при ошибке или достижении конца файла.

\begin{minted}{C++}
int fprintf(FILE *fp, const char *format, ...);
\end{minted}
Форматированный вывод в файл \mverb{fp}. По функционалу аналогичен \mverb{printf}, но результат пишется в файл. Возвращает количество записанных символов или отрицательное значение при ошибке.

\begin{minted}{C++}
int fscanf(FILE *fp, const char *format, ...);
\end{minted}
Форматированный ввод из файла \mverb{fp}. Аналог функции \mverb{scanf}, но данные читаются из файла. Возвращает количество успешно считанных элементов или \mverb{EOF} при ошибке.

\begin{minted}{C++}
void rewind(FILE *fp);
\end{minted}
Устанавливает указатель потока \mverb{fp} в начало файла, сбрасывая при этом ошибки потока.


\section{Функции для модификации содержимого файла: ferror, fwrite, fread, fileno, filelength, chsize, ftell, fgetpos, fseek}
Функции стандартной библиотеки C и некоторые дополнительные, которые используются для чтения, записи, 
управления положением в файле, а также для проверки ошибок и работы с свойствами файлов.

\begin{minted}{C++}
int ferror(FILE *fp);
\end{minted}
Проверяет состояние ошибки файла, связанного с потоком \mverb{fp}. Возвращает ненулевое значение, если произошла ошибка ввода-вывода, иначе 0.

\begin{minted}{C++}
size_t fwrite(const void *ptr, size_t size, size_t count, FILE *fp);
\end{minted}
Записывает count элементов по \mverb{size} байт из буфера \mverb{ptr} в файл \mverb{fp}. Возвращает количество успешно записанных элементов. Если количество меньше \mverb{count}, произошла ошибка или достигнут конец устройства.

\begin{minted}{C++}
size_t fread(void *ptr, size_t size, size_t count, FILE *fp);
\end{minted}
Читает count элементов по \mverb{size} байт из файла \mverb{fp} в буфер \mverb{ptr}. Возвращает количество успешно прочитанных элементов. Если количество меньше \mverb{count}, либо достигнут конец файла, либо произошла ошибка.

\begin{minted}{C++}
// (не является стандартной для ANSI C, но часто доступна в Unix-подобных и некоторых ОС)
int fileno(FILE *fp);
\end{minted}
Возвращает дескриптор файлового устройства, связанного с потоком \mverb{fp}. Используется для системных вызовов низкого уровня. В стандартном C отсутствует.

\begin{minted}{C++}
// (специфична для некоторых систем, например DOS/Windows)
long filelength(int fd);
\end{minted}
Возвращает длину файла в байтах по дескриптору \mverb{fd}. Не входит в стандарт ANSI C.

\begin{minted}{C++}
// (специфична для некоторых систем, например DOS/Windows)
int chsize(int fd, long size);
\end{minted} 
Изменяет размер файла, связанного с дескриптором \mverb{fd}, до \mverb{size} байт. Не стандартная функция ANSI C.

\begin{minted}{C++}
long ftell(FILE *fp);
\end{minted}
Возвращает текущую позицию указателя чтения-записи в файле \mverb{fp} как смещение в байтах от начала файла. При ошибке возвращает -1.

\begin{minted}{C++}
int fgetpos(FILE *fp, fpos_t *pos);
\end{minted}
Сохраняет текущую позицию указателя в pos для последующего восстановления. Возвращает 0 при успехе, ненулевое значение при ошибке.

\begin{minted}{C++}
int fseek(FILE *fp, long offset, int origin);
\end{minted}
Перемещает указатель чтения-записи в файле \mverb{fp} на \mverb{offset} байт относительно \mverb{origin}, который может принимать значения:
\begin{itemize}
\item \mverb{SEEK_SET} --- начало файла,
\item \mverb{SEEK_CUR} --- текущая позиция,
\item \mverb{SEEK_END} --- конец файла.
\end{itemize}
Возвращает 0 при успешном выполнении, иначе ненулевое значение.


