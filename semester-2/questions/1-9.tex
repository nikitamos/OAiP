\section{Понятие сложности алгоритма, оценки времени исполнения}
\section{Общая классификация вычислительных алгоритмов}
\section{Точность представления чисел}
\section{Строковый тип в C++. Представление в памяти. Автоматическое управление памятью для Си строк и std::string}
\section{Файлы. Двоичное и текстовое представление файлов. Стандартные файлы}
\section{Понятие потока. Открытие и закрытие файлов. Операции ввода- вывода. Указатель чтения-записи в файле}
\subsection{Поток}
\textbf{Поток} --- байтовая последовательность, передаваемая в процессе ввода-вывода.
Поток должен быть связан с каким-либо устройством или файлом на диске. В терминологии Си это звучит так:
поток должен быть направлен на какое-то устройство или файл. Любой файл рассматривается как байтовая последовательность.

Система ввода/вывода языка Си поддерживает интерфейс, не зависящий от того, какое в действительности используется физическое
устройство ввода/вывода, то есть абстрактный уровень между программистом и физическим устройством. Эта абстракция и называется
потоком. Способ же хранения информации на физическом устройстве называется файлом.

Несмотря на то, что устройства очень разные (терминал, дисководы, магнитная лента и др.), стандарт ANSI языка Си связывает каждое
из устройств с логическим устройством, называемым потоком. Так как потоки не зависят от физических устройств, то одна и та же функция
может записывать информацию на диск, на магнитную ленту или выводить ее на экран.

В языке Си существует два типа потоков: текстовый (text) и двоичный (binary).

\textbf{Текстовый поток}~--- это последовательность символов. Однако, символы, которые передаются в поток и выводятся на экран не всегда
взаимно однозначно соответствуют друг другу. Некоторые символы, например, возврат каретки или символ табуляции присутствуют в
файле, но на экране как бы теряются.

\textbf{Двоичный поток} – это последовательность байтов, которые взаимно однозначно соответствуют тому, что находится на внешнем устройстве.

Поток может быть связан с файлом с помощью оператора открытия файла. Как только файл открыт, то информация может передаваться между ним и Вашей программой.

Не все файлы одинаковы. К примеру, из файла на диске Вы можете выбрать 5-ую запись или заменить 10-ую запись.
В то же время в файл, связанный с печатающим устройством, информация может передаваться только последовательно
в том же порядке. Это иллюстрирует самое главное различие между потоками и файлами: все потоки одинаковы, что нельзя сказать о файлах.

Операция открытий файла связывает поток с определенным файлом. Операция закрытия файла разрывает эту связь. Если поток был открыт для
вывода, то при выполнении операции закрытия файла соответствующий буфер памяти записывается на внешнее устройство. Если программа закончила
работу нормально, то все файлы автоматически закрываются.

Каждый поток, связанный с файлом, имеет управляющую структуру, называемую FILE. Она описана в заголовочном файле \mverb{stdio.h}.

В файловой системе языка Си в начале выполнения каждой программы автоматически открываются 5 предопределенных потоков.
Три из ник относятся к стандартным потокам: \mverb{stdin} – стандартный поток ввода, \mverb{stdout} – стандартный поток
вывода, \mverb{stderr} – стандартный поток ошибок. Обычно эти потоки направляются к консоли (как известно, консоль~--- это
клавиатура+дисплей). Но можно перенаправлять их на другое устройство, в тех операционных системах, которые поддерживают
перенаправление. Перенаправление ввода/вывода поддерживаются такими операционными системами, как Windows, DOS, UNIX, OS/2.

\subsection{Открытие и закрытие файлов}
Прежде чем читать или записывать информацию в файл, он должен быть открыт и тем самым связан с потоком. Это можно сделать
с помощью библиотечной функции \mverb{fopen()}. Она берет внешнее представление файла (например: \verb|c:\\my_prog.txt|) и связывает его
с внутренним логическим именем, которое используется далее в программе. Логическое имя~---– это указатель на требуемый файл.
Его необходимо определить; делается это, например, так:
\begin{minted}{C++}
FILE *fp;
\end{minted}
Здесь \mverb{FILE} – имя типа, описанное в стандартном заголовочном файле \mverb{stdio.h}, \verb|fp| --- указатель на файл.
Обращение к функции \mverb{fopen()} в программе осуществляется выражением:
\begin{minted}{C++}
fp = fopen(спецификация файла, "способ использования файла");
\end{minted}

Спецификация файла (т.е. имя файла и путь к нему) может, например, иметь вид: \verb|c:\\my_prog.txt| – для файла \verb|my_prog.txt| на диске с:.

Если в результате обращения к функции \mverb{fopen()} возникает ошибка, то она возвращает константу \mverb{NULL}.

Работа с дисковым файлом начинается с объявления указателя на поток. Формат такого объявления:
\begin{minted}{C++}
FILE*имя указателя.
\end{minted}

Слово \mverb{FILE} является стандартным именем структурного типа, объявленного в заголовочном файле \verb|stdio.h|.
В структуре \mverb{FILE} содержится информация, с помощью которой ведется работа с потоком, в частности: указатель
на буфер, указатель (индикатор) текущей позиции в потоке и т.д.

Следующий шаг --- открытие потока, которое производится с помощью стандартной функции \mverb{fopen()}. Эта функция
возвращает конкретное значение для указателя на поток и поэтому ее значение присваивается объявленному ранее указателю.
Соответствующий оператор имеет формат:
\begin{minted}{C++}
имя_указателя=fopen(имя_файла, режим_открытия);
\end{minted}

Параметры функции \mverb{fopen()} являются строками, которые могут быть как константами, так и указателями на символьные массивы. Например:

\begin{minted}{C++}
fp=fopen(<<test.dat", <<r");
\end{minted}

Здесь \verb|test.dat| – это имя физического файла в текущем каталоге диска, с которым теперь будет связан поток с указателем \verb|fp|.
Параметр режима \verb|r| означает, что файл открыт для чтения. Что касается терминологии, то допустимо употреблять как выражение
<<открытие потока>>, так и выражение «открытие файла".

Надо хорошо понимать, что открытие уже существующего файла для записи ведет к потере прежней информации в нем. Если такой файл еще
не существует, то он создается. Открывать для чтения можно только существующий файл.

После работы с файлом он должен быть закрыт функцией \mverb{fclose()}. В процессе завершения программы незакрытые файлы автоматически закрываются системой.

\subsection{Позиционирование}
Любой файл, каким бы он ни был и как бы не обрабатывался, представляет собой просто последовательность байтов, файловый
указатель в каждый момент времени указывает на некоторый байт файла, начиная с которого будет выполняться следующая
операция. Любая операция с файлом каким-то образом изменяет положение файлового указателя. Например, при открытии файла
для чтения (\verb|r|) файловый указатель устанавливается на первый байт файла (более точно – файловый указатель, являющийся
обычной длинной переменной, принимает значение 0). То же самое происходит и при открытии файла для записи (\verb|w|), только
в этом случае старое содержимое файла (если оно было) теряется. А вот при открытии файла для дозаписи (\verb|a|) файловый
указатель устанавливается на конец файла. При чтении данных из файла указатель сдвигается вперед на количество байт, которое
занимают прочитанные данные. При записи в файл – тоже вперед на количество байт, которое занимают записанные данные.

Каждый открытый файл имеет так называемый указатель на текущую позицию в файле. Все операции над файлами (чтение и запись)
работают с данными данной позиции. При каждом выполнении функции чтения или записи указатель смещается на количество прочитанных
или записанных байт, т.е. устанавливается сразу за прочитанным или записанным блоком данных в файле. В этом случае осуществляется
так называемый последовательный доступ к данным, который очень удобен, когда нам необходимо последовательно работать с данными в файле.


\section{Проверка операций ввода-вывода. Пример}
\subsection{Для языка C}
При работе с файлами и потоками в языке Си обязательно необходимо проверять успешность операций ввода-вывода. Это позволяет своевременно
обнаружить ошибки и корректно их обработать.

\subsubsection{Проверка открытия файла}
Функция \mverb{fopen()} возвращает указатель на поток или \mverb{NULL} в случае ошибки (например, если файл не существует при открытии для чтения):

\begin{minted}{C++}
FILE *fp = fopen("file.txt", "r");
if (fp == NULL) {
    perror("Ошибка открытия файла");
    // Обработка ошибки
}
\end{minted}

\subsubsection{Проверка операций чтения и записи}
Функции чтения (\mverb{getc()}, f\mverb{read()} и др.) при достижении конца файла возвращают специальные значения (\mverb{EOF}
или количество прочитанных элементов меньше ожидаемого).

Функции записи (\mverb{putc()}, \mverb{fwrite()} и др.) могут возвращать значения, отличные от количества записанных элементов или \mverb{EOF}, что говорит об ошибке.
Пример проверки чтения символа:

\begin{minted}{C}
int ch = getc(fp);
if (ch == EOF) {
    if (feof(fp)) {
        // Конец файла
    } else if (ferror(fp)) {
        perror("Ошибка чтения файла");
    }
}
\end{minted}

\subsubsection{Проверка указателя файла после операций позиционирования}
Функция \mverb{fseek()} возвращает 0 при успешном выполнении, иначе ненулевое значение:
\begin{minted}{C}
if (fseek(fp, 0, SEEK_SET) != 0) {
    perror("Ошибка позиционирования в файле");
}
\end{minted}

\subsubsection{Проверка закрытия файла}
Функция \mverb{fclose()} возвращает 0 при успешном закрытии, и \verb|EOF| при ошибке:
\begin{minted}{C}
if (fclose(fp) != 0) {
    perror("Ошибка закрытия файла");
}
\end{minted}

\subsection{Для языка C++:}
В языке C++ для работы с файлами и потоками используется библиотека \mverb{<fstream>}, включающая классы \mverb{ifstream}
(ввод из файла), \mverb{ofstream} (вывод в файл) и \mverb{fstream} (и ввод, и вывод).

\subsubsection{Проверка открытия файла}
При создании объекта потока файла или вызове метода \mverb{open()} поток можно проверить с помощью движения логического
значения, метода \mverb{is_open()} или проверки состояния потока:
\begin{minted}{C++}
std::ifstream file("file.txt");
if (!file.is_open()) {
    std::cerr << "Ошибка открытия файла\n";
    // Обработка ошибки
}

// ИЛИ

std::ifstream file;
file.open("file.txt");
if (!file) {
    std::cerr << "Ошибка открытия файла\n";
}
\end{minted}

\subsubsection{Проверка состояния потока после операций}
Потоки в C++ имеют методы и операторы для проверки состояния:
\begin{itemize}
\item \mverb{good()} — поток в хорошем состоянии (нет ошибок и не \verb|EOF|)
\item \mverb{eof()} — достигнут конец файла
\item \mverb{fail()} — произошла ошибка операции ввода-вывода
\item \mverb{bad()} — серьёзная ошибка (например, сбой устройства)
\item \mverb{operator bool()} — поток готов к работе (эквивалентно \mverb{!fail()})
\end{itemize}
Пример чтения с проверкой:

\begin{minted}{C++}
char ch;
if (file.get(ch)) {
    // Символ успешно прочитан
} else if (file.eof()) {
    // Конец файла
} else if (file.fail()) {
    std::cerr << "Ошибка чтения файла\n";
}
\end{minted}
\subsubsection{Проверка записи}
Запись в файл через \mverb{ofstream} или \mverb{fstream} обычно проверяется состоянием потока:
\begin{minted}{C++}
std::ofstream out("output.txt");
out << "Пример текста";
if (!out) {
    std::cerr << "Ошибка записи файла\n";
}
\end{minted}

\subsection{Закрытие файла}
В C++ закрытие файла происходит автоматически при разрушении объекта потока. Если требуется
закрыть явно, используется метод \mverb{close()}.
Рекомендуется проверить состояние после закрытия:
\begin{minted}{C++}
file.close();
if (file.fail()) {
    std::cerr << "Ошибка закрытия файла\n";
}
\end{minted}

\section{Функции для модификации содержимого файла: futc, getc, feof, fputs, fgets, fprintf, fscanf, rewind}
Основные функции стандартной библиотеки C, применяемые для чтения, записи и управления положением указателя в файле:

\begin{minted}{C++}
int putc(int c, FILE *fp);
\end{minted}
Записывает символ c в файл, связанный с потоком \mverb{fp}. Возвращает записанный символ при успехе или \mverb{EOF} при ошибке.

\begin{minted}{C++}
int fgetc(FILE *fp);
\end{minted}
Читает символ из файла \mverb{fp}. Возвращает прочитанный символ или \mverb{EOF}, если достигнут конец файла или произошла ошибка.

\begin{minted}{C++}
int feof(FILE *fp);
\end{minted}
Проверяет, достигнут ли конец файла, связанного с потоком \mverb{fp}. Возвращает ненулевое значение, если конец файла достигнут, и 0, если нет.

\begin{minted}{C++}
int fputs(const char *str, FILE *fp);
\end{minted}
Записывает строку \mverb{str} в файл \mverb{fp}. Возвращает ненулевое значение при ошибке записи, иначе — положительное значение.

\begin{minted}{C++}
char *fgets(char *str, int n, FILE *fp);
\end{minted}
Читает строку из файла \mverb{fp} в буфер \mverb{str} длиной не более $n-1$ символов. Чтение заканчивается при достижении новой строки или конца файла. Возвращает \mverb{str} при успехе или \mverb{NULL} при ошибке или достижении конца файла.

\begin{minted}{C++}
int fprintf(FILE *fp, const char *format, ...);
\end{minted}
Форматированный вывод в файл \mverb{fp}. По функционалу аналогичен \mverb{printf}, но результат пишется в файл. Возвращает количество записанных символов или отрицательное значение при ошибке.

\begin{minted}{C++}
int fscanf(FILE *fp, const char *format, ...);
\end{minted}
Форматированный ввод из файла \mverb{fp}. Аналог функции \mverb{scanf}, но данные читаются из файла. Возвращает количество успешно считанных элементов или \mverb{EOF} при ошибке.

\begin{minted}{C++}
void rewind(FILE *fp);
\end{minted}
Устанавливает указатель потока \mverb{fp} в начало файла, сбрасывая при этом ошибки потока.


\section{Функции для модификации содержимого файла: ferror, fwrite, fread, fileno, filelength, chsize, ftell, fgetpos, fseek}
Функции стандартной библиотеки C и некоторые дополнительные, которые используются для чтения, записи, 
управления положением в файле, а также для проверки ошибок и работы с свойствами файлов.

\begin{minted}{C++}
int ferror(FILE *fp);
\end{minted}
Проверяет состояние ошибки файла, связанного с потоком \mverb{fp}. Возвращает ненулевое значение, если произошла ошибка ввода-вывода, иначе 0.

\begin{minted}{C++}
size_t fwrite(const void *ptr, size_t size, size_t count, FILE *fp);
\end{minted}
Записывает count элементов по \mverb{size} байт из буфера \mverb{ptr} в файл \mverb{fp}. Возвращает количество успешно записанных элементов. Если количество меньше \mverb{count}, произошла ошибка или достигнут конец устройства.

\begin{minted}{C++}
size_t fread(void *ptr, size_t size, size_t count, FILE *fp);
\end{minted}
Читает count элементов по \mverb{size} байт из файла \mverb{fp} в буфер \mverb{ptr}. Возвращает количество успешно прочитанных элементов. Если количество меньше \mverb{count}, либо достигнут конец файла, либо произошла ошибка.

\begin{minted}{C++}
// (не является стандартной для ANSI C, но часто доступна в Unix-подобных и некоторых ОС)
int fileno(FILE *fp);
\end{minted}
Возвращает дескриптор файлового устройства, связанного с потоком \mverb{fp}. Используется для системных вызовов низкого уровня. В стандартном C отсутствует.

\begin{minted}{C++}
// (специфична для некоторых систем, например DOS/Windows)
long filelength(int fd);
\end{minted}
Возвращает длину файла в байтах по дескриптору \mverb{fd}. Не входит в стандарт ANSI C.

\begin{minted}{C++}
// (специфична для некоторых систем, например DOS/Windows)
int chsize(int fd, long size);
\end{minted} 
Изменяет размер файла, связанного с дескриптором \mverb{fd}, до \mverb{size} байт. Не стандартная функция ANSI C.

\begin{minted}{C++}
long ftell(FILE *fp);
\end{minted}
Возвращает текущую позицию указателя чтения-записи в файле \mverb{fp} как смещение в байтах от начала файла. При ошибке возвращает -1.

\begin{minted}{C++}
int fgetpos(FILE *fp, fpos_t *pos);
\end{minted}
Сохраняет текущую позицию указателя в pos для последующего восстановления. Возвращает 0 при успехе, ненулевое значение при ошибке.

\begin{minted}{C++}
int fseek(FILE *fp, long offset, int origin);
\end{minted}
Перемещает указатель чтения-записи в файле \mverb{fp} на \mverb{offset} байт относительно \mverb{origin}, который может принимать значения:
\begin{itemize}
\item \mverb{SEEK_SET} --- начало файла,
\item \mverb{SEEK_CUR} --- текущая позиция,
\item \mverb{SEEK_END} --- конец файла.
\end{itemize}
Возвращает 0 при успешном выполнении, иначе ненулевое значение.


