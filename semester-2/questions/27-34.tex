%cSpell:enableCompoundWords
\section{Шейкерная сортировка. Сортировка Шелла}

\section{Сортировка Хоара – алгоритм QuickSort. Сортировка слиянием}
\subsection{QuickSort (быстрая сортировка)}
Time Complexity --- $O(n\log n)$ в среднем, $O(n^2)$
в худшем (если входной массив уже отсортирован) случае. Space Complexity зависит 
от функции разбиения (функция Хоара дает $\log n$).

Быстрая сортировка функционирует по принципу <<разделяй и властвуй>>.
Пусть требуется отсортировать массив из $n$ элементов $a[1\dots n]$ (обе границы включены).
На первом шаге полагаем $l=1$ и $r=n$. Далее придерживаемся следующего алгоритма:
\begin{enumerate}
  \item Вычислить индекс $q$ опорного элемента.
  \item Массив $a[l\dots r]$
  разбивается на два подмассива $a[l\dots q]$ и $a[q+1\dots r]$, таких что каждый элемент $a[l\dots q]$
  меньше или равен $a[q]$, который в свою очередь, не превышает любой элемент подмассива $a[q+1\dots r]$, то есть
  \begin{align*}
    \forall n <& q \quad a[n] \leq a[q] \\
    \forall m >& q \quad a[q] \leq a[m].
  \end{align*}
  \item Подмассивы $a[l\dots q]$ и $a[q+1\dots r]$ сортируются рекурсивно.
\end{enumerate}

Распространенной является функция разбиения Хоара, которая выбирает средний элемент массива
в качестве опорного.

Отметим, что в качестве опорного можно выбирать абсолютно любой элемент массива
(даже всегда первый, но при такой реализации сложность любого случая будет $\Theta(n^2)$).

Если кому-либо известен алгоритм функции разбиения, то он может злонамеренно соорудить
такой массив, на котором функция быстрой сортировки уйдет в $O(n^2)$ и/или возникнет
переполнение стека. Чтобы избежать этого, в качестве опорного можно выбирать случайный
элемент массива.

Ниже приведен алгоритм Quicksort с разбиением Хоара.
\begin{minted}{C++}
#include <iostream>
#include <utility>

/// a - массив, который сортируется
/// l - левая граница сортируемого отрезка
/// r - правая граница
int Partition(int *a, int l, int r) {
  int v = a[(l + r) / 2];
  int i = l;
  int j = r;
  while (i <= j) {
    while (a[i] < v) {
      ++i;
    }
    while (a[j] > v) {
      --j;
    }
    if (i >= j) {
      break;
    }
    std::swap(a[i++], a[j--]);
  }
  return j;
}

void Quicksort(int *a, int l, int r) {
  if (l < r) {
    int q = Partition(a, l, r);
    Quicksort(a, l, q);
    Quicksort(a, q + 1, r);
  }
}

int main() {
  int a[7] = {5, 10, -2, -3, 0, 1, 7};
  Quicksort(a, 0, 6);
  for (int i = 0; i < 7; ++i) {
    std::cout << a[i] << ' ';
  }
  std::cout << '\n';
}
\end{minted}

% TODO: Check & add code
\paragraph{Сортировка слиянием.}
Разделяет исходный массив на два равных подмассива, после чего рекурсивно сортирует их по отдельности и объединяет.
Массивы разделяются до тех пор, пока в них не останется одного элемента.

Алгоритм сортировки таков:
\begin{enumerate}
  \item Если в массиве 1 элемент --- завершиться.
  \item Найти середину массива.
  \item Посортировать первую половину.
  \item Посортировать вторую половину.
  \item Объединить массив.
\end{enumerate}

Алгоритм объединения массивов:
\begin{enumerate}
  \item Циклично проходим по двум массивам.
  \item В объединяемый ставим тот элемент, что меньше.
  \item Двигаемся дальше, пока не дойдем до конца обоих массивов.
\end{enumerate}

Time Complexity: $O(n\log n)$, Space Complexity: $O(n)$.

\section{Бинарные деревья – основные понятия. Основные операции с бинарными деревьями}
\subsection{Определения}
\textbf{Дерево} --- связный ациклический иерархически построенный граф. Граф обычно
полагается ориентированным в направлении иерархии: в каждую вершину (кроме одной,
называемой \textbf{корнем}) входит ровно одно ребро, но исходить из вершины может
произвольное количество ребер. Каждой вершине при этом сопоставляются какие-либо данные.

\textbf{Бинарным (двоичным) деревом} называется такое дерево, из каждой вершины которого
исходит не более двух ребер.

Когда речь идет о структурах данных, вершины принято называть \textbf{узлами}.
Данные, находящиеся в конкретном узле называют его \textbf{ключом}, а если дерево задает
отображение, то к ключам также добавляется \textbf{значения}.
% Картинка

\textbf{Ветвь} дерева --- дуга, соединяющая два узла. 

\textbf{Лист (терминальный узел)} --- узел, не имеющий исходящих ветвей.

\textbf{Внутренний узел} --- узел, имеющий как входящие, так и исходящие ветви.

Каждая ветвь задает пару \textbf{родителя} --- узла, из которого данная ветвь исходит
и \textbf{потомка} --- узла, в который данная ветвь входит. Потомками также называют
потомков потомков.

\textbf{Поддеревом} дерева называется некоторый узел вместе со всеми своими потомками.

\textbf{Глубина (уровень)} узла --- расстояние от узла до корня.

\textbf{Высота} узла --- максимальное расстояние от узла до корня. Высота дерева считается
равной высоте его корня.

% Полнота, завершенность, идеальность?
К основным операциям на деревьях относятся добавление, удаление и поиск узла (см. вопрос \ref{sec:tree-node-ops}), а также обход дерева.

\subsection{Обход}
\textbf{Обход дерева} --- посещение всех узлов дерева в определенном порядке и обработка содержащихся в них данных.
Выделяют четыре основных порядка обхода: в ширину, в прямом порядке, в обратном порядке и в симметричном порядке.
Алгоритм обхода в ширину использует $O(n)$ дополнительной памяти, остальные алгоритмы используют $O(\log n)$ памяти
на \textit{стек вызовов} {\color{red} TODO: ссылка на вопрос про стек вызовов}.

Предположим, что мы имеем дело с бинарным деревом поиска. Тогда обход в прямом порядке будет обрабатывать значения
в порядке их возрастания. Ниже приведен алгоритм обхода в прямом порядке на псевдокоде.
\begin{algorithmic}[1]
  \Function{InOrder}{Node n}
    \State Handle n
    \Comment{Обработать n}
    \If{n has left child}
      \State \Call{InOrder}{n.left}
      \Comment{Посетить левое поддерево}
    \EndIf

    \If{n has right child}
      \State \Call{InOrder}{n.right}
      \Comment{Посетить правое поддерево}
    \EndIf
  \EndFunction
\end{algorithmic}

Алгоритм обхода в обратном порядке:
\begin{algorithmic}[1]
  \Function{PostOrder}{Node n}
    \If {n has left child}
      \State \Call{PostOrder}{n.left}
    \EndIf
    \If{n has right child}
      \State \Call{PostOrder}{n.right}
    \EndIf
    \State Handle n
  \EndFunction
\end{algorithmic}

% TODO: симметричный обход

Алгоритм обхода дерева в ширину посещает дерево слой за слоем: сначала посещается корневой узел,
затем его дети (все вершины глубины 1), после них алгоритм посещает все вершины глубины 2 и так
далее, пока не будут исчерпаны все вершины.
\begin{algorithmic}[1]
  \Function{Bfs}{Node n}
    \State q $\gets$ empty Queue
    \State \Call{q.Push}{n}
    \While{q is not empty}
      \State m $\gets$ q.\Call{Pop}{}
      \State Handle m
      \If {n has left child}
        \State q.\Call{Push}{n.left}
      \EndIf
      \If{n has right child}
        \State q.\Call{Push}{n.right}
      \EndIf
    \EndWhile
  \EndFunction
\end{algorithmic}

\section{Понятие рекурсивного типа данных}
\section{Поиск и включение для деревьев. Исключение для деревьев}
\label{sec:tree-node-ops}
\section{Сбалансированные деревья. Сортировка с помощью бинарных деревьев (кучи)}
\section{Графы и возможные формы их описания. Нахождение кратчайшего пути на графе}
\section{Алгоритм Дейкстры, алгоритм Форда}