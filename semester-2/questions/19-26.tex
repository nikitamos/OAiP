\section{Понятие стека. Операции над стеком. Программная реализация стека на основе статического массива}
\subsection{Понятие стека}
Стек~--- абстрактный тип данных, представляющий собой список элементов, организованных по принципу
LIFO (англ. last in -- first out, «последним пришёл -- первым вышел>>). Стеки могут быть построены на основе других, более фундаментальных
структурах данных, например, можно реализовать стек как обертку над массивом с указателем или на основе списка. Проще говоря, стек представляет
собой абстрактный интерфейс доступа к данным, а не конкретную структуру данных.

Организация данных по принципу LIFO означает, что элементы могут добавляться и извлекаться только с вершины стека. При этом при добавлении
элемента, именно он становится новой вершиной стека, а при удалении, вершиной становится предыдущий элемент.

\includegraphics[width=0.9\textwidth]{resources/19-26/stack.png}

В стандартной библиотеке С++ присутствует реализация \cppref[стека]{cpp/container/stack}, объявленная в соответствующем
\cppref[заголовке]{cpp/header/stack}. Стоит отметить, что шаблон \mverb{std::stack<T>} не является
структурой данных сам по себе, а лишь предоставляет интерфейс стека поверх какой-либо другой структуры (по умолчанию, \cppref[\texttt{std::deque<T>}]{cpp/container/deque}).
Помимо этого, в качестве стека можно тривиально использовать динамический массив \cppref[\texttt{std::vector<T>}]{cpp/container/vector} с его
методами \mverb{push_back(T &&)}, \mverb{back()} и \mverb{pop_back()}.
\subsection{Операции над стеком}
Когда речь идет о стеке, подразумевается структура данных со следующими операциями:
\begin{enumerate}
  \item Добавить элемент в верхушку стека (\mverb{push()}).
  \item Удалить элемент из верхушки стека (\mverb{pop()}).
\end{enumerate}

Часто также требуется поддержка операции чтения вершины без ее удаления (\mverb{peek()}, также \mverb{top()}) и
проверки на пустоту (\mverb{empty()}). В специализированной эффективной реализации все вышеназванные операции имеют временную сложность
\(O(1)\).

\subsection{Пример реализации стека}
Приведем реализацию стека на основе статического массива фиксированной длины. Данная реализация будет использовать шаблоны и
\cppref[\texttt{assert(bool)}]{cpp/error/assert} для проверок инвариантов.

\section{Понятие очереди. Операции над очередями. Кольцевая очередь. Деки.  Программная реализация очереди на основе статического массива}
Очередь~--- абстрактный тип данных, представляющий собой список данных, организованных по принципу FIFO (англ. first in -- first out, <<первым пришел первым вышел>>).
Очереди могут быть построены на основе других, более фундаментальных структурах данных. Например, очередь может быть внутренне реализована как
список. Об очереди можно судить скорее как об интерфейсе доступа к данным.

Организация по принципу FIFO означает, что элементы могут извлекаться с одного конца (головы), а добавляться~--- с другого (хвоста).

\includegraphics[width=0.9\textwidth]{resources/19-26/queue.png}

В стандартной библиотеке C++ присутствует \cppref[шаблон класса]{cpp/container/queue} \mverb{std::queue<T>}, который является оберткой поверх
какого-либо другого контейнера (по умолчанию, \cppref[\texttt{std::deque<T>}]{cpp/container/deque}).

\subsection{Операции над очередями}
Когда речь идет об очереди, подразумевается структура данных со следующими операциями:
\begin{enumerate}
  \item Добавить элемент в конец (хвост) очереди (\mverb{enqueue()}, в С++ \mverb{push()}).
  \item Удалить элемент из головы очереди (\mverb{dequeue()}, в C++ \mverb{pop()}).
\end{enumerate}
%
Часто также требуется операция чтения головы (\mverb{front()}) и проверки на пустоту (\mverb{empty()}). В эффективной реализации
все указанные операции должны выполнятся за \(O(1)\).

\subsection{Кольцевая очередь}
Кольцевая очередь (кольцевой буфер)~--- очередь (с фиксированным размером), в которой голова и хвост соединены.

\begin{center}
  \includegraphics[width=0.3\textwidth]{resources/19-26/ring.png}
\end{center}

Кольцевая очередь может быть эффективно реализована на основе массива с двумя указателями: один для чтения, второй~--- для записи.

Кольцевой буфер находит очень широкое применение в том числе при программировании микроконтроллеров.
Данные структуры часто используют для организации различных очередей сообщений и буферов приёма-передачи различных
коммуникационных интерфейсов. Такая структура также легко предоставляет возможность буферизации потоков данных.

\subsection{Deque}
Дек (англ. deque, double-ended queue)~--- абстрактный тип данных, в котором элементы можно добавлять и удалять как в начало, так и в конец.
От дека требуются следующие операции (работают за \(O(1)\) в эффективной реализации):
\begin{enumerate}
  \item Вставка в начало (\mverb{push_front()}).
  \item Вставка в конец (\mverb{push_back()}).
  \item Удаление из начала (\mverb{pop_front()}).
  \item Удаление с конца (\mverb{pop_back()}).
\end{enumerate}

Помимо этого, существуют варианты деков, поддерживающих также произвольный доступ за \(O(1)\), в частности, такую асимптотическую
сложность гарантирует \cppref[\texttt{std::deque<T>}]{cpp/container/deque}.

\subsection{Реализация очереди}

\section{Использование очередей при реализации запросов ввода-вывода. Структура данных «список»}
\section{Программная реализация очереди на основе статического массива}
\section{Многократный поиск на основе использования статистических данных}
\section{Нечеткий поиск – поиск «подобной» подстроки. Бинарный поиск}

\section{Рекурсия: общий вид, свойства, проблемы. Стек вызова функций}
Рекурсия~--- метод решения вычислительной задачи, при котором решение зависит от решения меньших подзадач того же рода. Такие задачи решаются
при помощи функций (методов), вызывающих самих себя для меньших объемов данных.

Можно доказать, что рекурсия по вычислительной способности эквивалентна программам с циклами, что делает
рекурсию мощным инструментом решения алгоритмических задач\footnote{Существуют языки программирования (например, Haskell или Clojure),
  в которых рекурсия является единственным способом повторно вызывать код. При этом такие языки по своем вычислительной
  способности эквивалентны более традиционным языкам.}.

Чтобы функция была рекурсивной, необходимо и достаточно наличие в этой функции вызова самой себя при каких-либо путях выполнения кода. При этом
не обязательно, чтобы вызов функции самой себя был указан напрямую в теле этой функции (\textit{прямая рекурсия}), рекурсивный вызов может
выполнятся и в какой-либо другой функции, вызываемой данной (\textit{косвенная рекурсия}).

У рекурсии, как метода решения алгоритмических задача, есть определенные достоинства и недостатки:
\begin{itemize}
  \item Простота~--- рекурсивные решения часто проще и элегантнее итеративных.
  \item Мощность~--- рекурсивные решения эквивалентны итеративным, причем некоторые задачи гораздо проще решить
        именно рекурсивным способом.
  \item Накладные расходы~--- вызов функций имеет определенные временные затраты, заметные в случае сравнительно
        простых для вычисления функций. Тогда временные затраты на вызовы будут занимать существенное по сравнению с
        полезными вычислениями время.
  \item Проблема переполнения стека~--- вызов функций, требующий дополнительную память сопряжен риском исчерпания машинного стека
        вызова и аварийного завершения программы при достаточно большом объеме входных данных и высокой глубине рекурсии.
\end{itemize}

\subsection{Классификация рекурсии}
Рекурсия может быть классифицирована по различным признакам:
\begin{enumerate}
  \item По типу вызова
        \begin{itemize}
          \item Прямая рекурсия~--- функция взывает саму себя непосредственно.
          \item Косвенная рекурсия~--- функция вызывает функцию, которая вызывает исходную.
        \end{itemize}
  \item По структуре вызова
        \begin{itemize}
          \item Хвостовая рекурсия~--- если рекурсивный вызов является последней операции перед возвратом из функции.
          \item Нехвостовая рекурсия~--- в противном случае.
        \end{itemize}
  \item По направлению вызова
        \begin{itemize}
          \item Восходящая рекурсия~--- функция разбивает задачу на подзадачи, которые решаются рекурсивно.
          \item Нисходящая рекурсия~--- функция сначала решает подзадачи рекурсивно, а затем объединяет результаты.
        \end{itemize}
  \item По степени ветвления
        \begin{itemize}
          \item Линейная~--- рекурсивные вызовы на любом рекурсивном срезе, инициируют не более одного последующего рекурсивного вызова.
          \item Нелинейная рекурсия~--- в противном случае.
        \end{itemize}
\end{enumerate}

Приведем несколько примеров:
\begin{minted}{C++}
// Рекурсивное вычисление факториала числа
// Пример прямой нехвостовой нисходящей линейной рекурсии
int32_t Factorial(int32_t n) {
  return n <= 1 ? 1 : n * factorial(n - 1);
}

// Еще один факториал, оптимизированная версия
// Пример прямой хвостовой восходящей линейной рекурсии
int32_t FactorialRec(int32_t n, int32_t acc) {
  return n <= 1 ? 1 : factorial_rec(n - 1, n * acc);
}
int32_t BetterFactorial(int32_t n) {
  return FactorialRec(n, 1);
}

// Функция Аккермана
// Пример прямой нехвостовой нисходящей нелинейной рекурсии
int32_t A(int32_t m, int32_t n) {
  if (m == 0) {
    return n + 1;
  }
  if (n == 0) {
    return A(m - 1, 1);
  }

  return A(m - 1, A(m, n - 1));
}
\end{minted}

\section{Сортировки – общая классификация. Сортировки с помощью включения, выделения, обменов}
Сортировка~--- процесс упорядочивания данных в соответствии с заданным критерием.

Сортировка является фундаментальной операцией при работе с данными, поскольку позволяет работать с ними более
эффективно.

