\newcommand{\asgn}{\gets\,}
\section{Множества. Основные операции: проверка, добавление, удаление. Реализация списком, массивом, битовой картой}
\section{Словари и хеш-таблицы. Хеширование, хеш-функции. Коллизии хеширования}
\section{Обработка (разрешение) коллизий хеширования: прямое связывание, "открытая адресация"}
\section{Иерархические списки, деревья. Основные определения, связанные с деревьями}
Через $n$ будем обозначать общее число узлов в дереве.

В линейном списке каждый элемент связан с одним последующим. В иерархическом списке
каждый элемент может быть связан с несколькими последующими элементами, тем самым
образуя иерархию, в которой данному элементу подчинены связанные с ним последующие
элементы. Данное понятие приводит к определению дерева.

\textbf{Дерево} --- связный ациклический иерархически построенный граф. Граф обычно
полагается ориентированным в направлении иерархии: в каждую вершину (кроме одной,
называемой \textbf{корнем}) входит ровно одно ребро, но исходить из вершины может
произвольное количество ребер. Каждой вершине при этом сопоставляются какие-либо данные.

Когда речь идет о структурах данных, вершины принято называть \textbf{узлами}.
Данные, находящиеся в конкретном узле называют его \textbf{ключом}, а если дерево задает
отображение, то к ключам также добавляется \textbf{значения}.

\textbf{Ветвь} дерева --- дуга, соединяющая два узла. 

\textbf{Лист (терминальный узел)} --- узел, не имеющий исходящих ветвей.

\textbf{Внутренний узел} --- узел, имеющий как входящие, так и исходящие ветви.

Каждая ветвь задает пару \textbf{родителя} --- узла, из которого данная ветвь исходит
и \textbf{потомка} --- узла, в который данная ветвь входит. Потомками также называют
потомков потомков.

\textbf{Поддеревом} дерева называется некоторый узел вместе со всеми своими потомками.

\textbf{Глубина (уровень)} узла --- расстояние от узла до корня.

\textbf{Высота} узла --- максимальное расстояние от узла до листа. Высота дерева считается
равной высоте его корня.

Дерево называется \textbf{сбалансированным}, если максимальное значения модуля разности глубин
любых двух его листов не превышает единицы.

\textbf{Полное} дерево – все узлы имеют либо одинаковую степень, максимальную для данного дерева, или нулевую (т.е. являются
листьями).

\textbf{Завершенное} дерево – все уровни являются полными, кроме, возможно, последнего (для которого узлов не хватило).

\textbf{Идеальное} дерево – завершенное дерево, у которого полон и последний уровень (т.е. последний уровень состоит
только из листьев, и все листья находятся в последнем уровне). Идеальное дерево содержит максимальное для его высоты
количество узлов.

% \textbf{Бинарной кучей} называется бинарное дерево, для которого выполнено следующее:
% \begin{enumerate}
%   \item Значение в каждой вершине не больше (не меньше), чем в ее потомках;
%   \item Дерево сбалансировано;
%   \item Последний слой заполнен слева направо без дырок.
% \end{enumerate}
% Кучи подробнее рассмотрены в \ref{sec:heap}.

\section{Бинарные деревья - основные понятия. Основные операции с бинарными деревьями}
Дерево называется \textbf{бинарным}, если каждый его узел имеет не более двух потомков.
Естественно, что для бинарных деревьев также вводятся все понятия из предыдущего вопроса.
\phantomsection
\label{def:bst}
Бинарное дерево называется бинарным \textbf{деревом поиска}, если для любого его узла выполнено:
\begin{enumerate}
  \item Ключи левого ребенка и всех его потомков не превосходит ключ данного узла;
  \item Ключ данного узла не превосходит ключей его правого ребенка и всех потомков последнего.
\end{enumerate}
В случае несуществования у узла какого-либо ребенка в данном определении следует опустить соответствующее условие.
{\small\itshape Замечание. В данных условиях можно одновременно заменить знак неравенства на противоположный.}

Все определения, введенные в предыдущем вопросе, также распространяются на бинарные деревья.

Основными операциями над бинарными деревьями являются \hyperref[sec:bintree-traversal]{обход деревьев},
\hyperref[sec:tree-ins-del]{вставка, удаление} и поиск элементов (для упорядоченных деревьев).

Алгоритм поиска элемента в упорядоченных деревьях прост: мы сравниваем элемент, содержащийся в каждом узле,
с искомым. Если они совпадают, то возвращаем узел. Если искомый элемент меньше, то продолжаем поиск в левом
поддереве, иначе~--- в правом.
\begin{algorithmic}
\Function{Find}{Node $root$, Value $key$}
  \While{$root$ is not null}
    \If{$root$.key = $key$}
      \State \Return $root$
    \ElsIf{$root$.key < $key$}
      \State $root$ \asgn $root$.left
    \Else
      \State $root$ \asgn $root$.right
    \EndIf
  \EndWhile
  \State \Return not found
\EndFunction
\end{algorithmic}

\section{Алгоритмы обхода дерева (поиск в неупорядоченном дереве)}
\label{sec:tree-traversal}

\subsection{Поиск в ширину (BFS)}
Этот алгоритм раскрывает дерево слой за слоем:
сперва посещается корень, затем его дети, за ними ---
все их дети, и так далее. Алгоритм BFS имеет сложность $O(n)$ требует
$O(n)$ дополнительной памяти.
\begin{algorithmic}
\Procedure{BFS}{Node $n$}
  \State $q$ \asgn empty Queue
  \State $q$.\Call{Enqueue}{$n$}
  \While{$q$ is not empty}
    \State $n$ \asgn $q$.\Call{Dequeue}{}
    \State Process $n$.data
    \ForAll{children $m$ of $n$}
      $q$.\Call{Enqueue}{$m$}
    \EndFor
  \EndWhile
\EndProcedure
\end{algorithmic}

\subsection{Поиск в глубину (DFS)}
Алгоритм DFS раскрывает дерево по веткам: сперва он доходит от корня до листа,
обрабатывая все посещенные вершины, затем он возвращается наверх, аналогичным
образом обрабатывая нераскрытые ветви. Вычислительная трудоемкость алгоритма
DFS такая же, как у BFS, однако для сбалансированных деревьев он требует $O(\log n)$
дополнительной памяти.
Реализацию DFS можно получить путем замены в алгоритме BFS очереди на стек:
\begin{algorithmic}
\Procedure{DFS}{Node $n$}
  \State $q$ \asgn empty Stack
  \State $q$.\Call{Push}{$n$}
  \While{$q$ is not empty}
    \State $n$ \asgn $q$.\Call{Pop}{}
    \State Process $n$.data
    \ForAll{children $m$ of $n$}
      $q$.\Call{Push}{$m$}
    \EndFor
  \EndWhile
\EndProcedure
\end{algorithmic}

Существует также рекурсивная реализация DFS, которая в качестве стека использует
стек вызовов.
\begin{algorithmic}
\Procedure{DFSRecursive}{Node $n$}
  \State Process $n$.data
  \ForAll{children $m$ of $n$}
    \State \Call{DFSRecursive}{$m$}
  \EndFor
\EndProcedure
\end{algorithmic}

\subsection{Обход бинарных деревьев}
\label{sec:bintree-traversal}
Для бинарных деревьев вводят несколько подвидов поиска в глубину,
которые определяют конкретный порядок посещения и обработки узла и его поддеревьев.

Алгоритм обхода в \textbf{прямом порядке} (Pre-order, NLR) обрабатывает узел перед
посещением поддеревьев.
\begin{algorithmic}
  \Function{PreOrder}{Node n}
    \State Process n
    \Comment{Обработать n}
    \If{n has left child}
      \State \Call{PreOrder}{n.left}
      \Comment{Посетить левое поддерево}
    \EndIf
    \If{n has right child}
      \State \Call{PreOrder}{n.right}
      \Comment{Посетить правое поддерево}
    \EndIf
  \EndFunction
\end{algorithmic}

Алгоритм обхода в \textbf{обратном порядке} (Post-order, LRN) обрабатывает узел после
посещения поддеревьев.
\begin{algorithmic}
  \Function{PostOrder}{Node n}
    \If {n has left child}
      \State \Call{PostOrder}{n.left}
    \EndIf
    \If{n has right child}
      \State \Call{PostOrder}{n.right}
    \EndIf
    \State Process n
  \EndFunction
\end{algorithmic}

Алгоритм обхода в \textbf{симметричном порядке} (In-order, LNR) обрабатывает узел между
посещениями поддеревьев. Если дерево является BST, то элементы обрабатываются в отсортированном
порядке.
\begin{algorithmic}
  \Function{InOrder}{Node n}
    \If {n has left child}
      \State \Call{InOrder}{n.left}
    \EndIf
    \State Process n
    \If{n has right child}
      \State \Call{InOrder}{n.right}
    \EndIf
  \EndFunction
\end{algorithmic}

\section{Добавление и удаление элементов дерева}
\label{sec:tree-ins-del}
Добавление и удаление элементов в \hyperref[def:bst]{бинарном дереве поиска} необходимо проводить таким образом,
чтобы сохранялось его свойство упорядоченности. Добавление и удаление элементов в неупорядоченном дереве без
инвариантов не отличается от такового для списков.

Рассмотрим операции удаления и добавления элементов в бинарное дерево поиска.
\subsection{Добавление}
Добавление работает аналогично поиску, однако при обнаружении у элемента отсутствия ребенка
нужно подвесить на него вставляемый элемент.
\begin{minted}{C++}
Node* Insert(Node* root, int value) {
  while (root != nullptr) {
    if (value < root->data) {
      if (root->left != nullptr) {
        root = root->left;
      } else {
        root->left = new Node(value);
        root->left->parent = root;
        return root->left;
      }
    } else if (root->data < value) {
      if (root->right != nullptr) {
        root = root->right;
      } else {
        root->right = new Node(value);
        root->right->parent = root;
        return root->right;
      }
    } else {
      // Value already exists in the tree
      return root;
    }
  }
  return n;
}
\end{minted}
\subsection{Удаление}
Для удаления узла с заданным значением его сперва надо найти. Затем мы столкнемся с одним из трех случаев:
\begin{enumerate}
  \itembf{Узел имеет двух детей.} Данный узел заменяется наибольшим узлом в левом поддереве либо наименьшим узлом в правом, после чего удаляется.
  \itembf{Узел листовой.} Он просто удаляется, ссылка родителя на этот узел устанавливается в \mverb{nullptr}.
  \itembf{Узел имеет одного ребенка.} Вместо данного узла к его родителю подвешивается единственный ребенок. Данный узел удаляется.
\end{enumerate}
Ниже приведена простая реализация для дерево с узлами без ссылок на родителей. Реализация для дерева
со ссылками на родителей более громоздкая и может быть найдена по адресу:
\url{https://neerc.ifmo.ru/wiki/index.php?title=Дерево_поиска,_наивная_реализация}.
\begin{minted}{C++}
struct Node {
  Node *left;
  Node *right;
  int key;
};

Node *Delete(Node *root, int value) {
  if (root == nullptr) {
    return root;
  }
  if (value < root->key)
    root->left = Delete(root->left, value);
  else if (value > root->key)
    root->right = Delete(root->right, value);
  else if (root->left != nullptr && root->right != nullptr) {
    root->key = MinNode(root->right).key;
    root->right = Delete(root->right, root->key);
  } else {
    if (root->left != nullptr)
      root = root->left;
    else if (root->right != nullptr)
      root = root->right;
    else
      root = nullptr;
  }
  return root;
}
\end{minted}