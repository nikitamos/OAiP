\newcommand{\asgn}{\gets\,}
\section{Множества. Основные операции: проверка, добавление, удаление. Реализация списком, массивом, битовой картой}
\section{Словари и хеш-таблицы. Хеширование, хеш-функции. Коллизии хеширования}
\section{Обработка (разрешение) коллизий хеширования: прямое связывание, "открытая адресация"}
\section{Иерархические списки, деревья. Основные определения, связанные с деревьями}
Через $n$ будем обозначать общее число узлов в дереве.

В линейном списке каждый элемент связан с одним последующим. В иерархическом списке
каждый элемент может быть связан с несколькими последующими элементами, тем самым
образуя иерархию, в которой данному элементу подчинены связанные с ним последующие
элементы. Данное понятие приводит к определению дерева.

\textbf{Дерево} --- связный ациклический иерархически построенный граф. Граф обычно
полагается ориентированным в направлении иерархии: в каждую вершину (кроме одной,
называемой \textbf{корнем}) входит ровно одно ребро, но исходить из вершины может
произвольное количество ребер. Каждой вершине при этом сопоставляются какие-либо данные.

Когда речь идет о структурах данных, вершины принято называть \textbf{узлами}.
Данные, находящиеся в конкретном узле называют его \textbf{ключом}, а если дерево задает
отображение, то к ключам также добавляется \textbf{значения}.

\textbf{Ветвь} дерева --- дуга, соединяющая два узла. 

\textbf{Лист (терминальный узел)} --- узел, не имеющий исходящих ветвей.

\textbf{Внутренний узел} --- узел, имеющий как входящие, так и исходящие ветви.

Каждая ветвь задает пару \textbf{родителя} --- узла, из которого данная ветвь исходит
и \textbf{потомка} --- узла, в который данная ветвь входит. Потомками также называют
потомков потомков.

\textbf{Поддеревом} дерева называется некоторый узел вместе со всеми своими потомками.

\textbf{Глубина (уровень)} узла --- расстояние от узла до корня.

\textbf{Высота} узла --- максимальное расстояние от узла до листа. Высота дерева считается
равной высоте его корня.

Дерево называется \textbf{сбалансированным}, если максимальное значения модуля разности глубин
любых двух его листов не превышает единицы.

\textbf{Полное} дерево – все узлы имеют либо одинаковую степень, максимальную для данного дерева, или нулевую (т.е. являются
листьями).

\textbf{Завершенное} дерево – все уровни являются полными, кроме, возможно, последнего (для которого узлов не хватило).

\textbf{Идеальное} дерево – завершенное дерево, у которого полон и последний уровень (т.е. последний уровень состоит
только из листьев, и все листья находятся в последнем уровне). Идеальное дерево содержит максимальное для его высоты
количество узлов.

% \textbf{Бинарной кучей} называется бинарное дерево, для которого выполнено следующее:
% \begin{enumerate}
%   \item Значение в каждой вершине не больше (не меньше), чем в ее потомках;
%   \item Дерево сбалансировано;
%   \item Последний слой заполнен слева направо без дырок.
% \end{enumerate}
% Кучи подробнее рассмотрены в \ref{sec:heap}.

\section{Бинарные деревья - основные понятия. Основные операции с бинарными деревьями}
Дерево называется \textbf{бинарным}, если каждый его узел имеет не более двух потомков.
Естественно, что для бинарных деревьев также вводятся все понятия из предыдущего вопроса.
\phantomsection
\label{def:bst}
Бинарное дерево называется бинарным \textbf{деревом поиска}, если для любого его узла выполнено:
\begin{enumerate}
  \item Ключи левого ребенка и всех его потомков не превосходит ключ данного узла;
  \item Ключ данного узла не превосходит ключей его правого ребенка и всех потомков последнего.
\end{enumerate}
В случае несуществования у узла какого-либо ребенка в данном определении следует опустить соответствующее условие.
{\small\itshape Замечание. В данных условиях можно одновременно заменить знак неравенства на противоположный.}

Все определения, введенные в предыдущем вопросе, также распространяются на бинарные деревья.

Основными операциями над бинарными деревьями являются \hyperref[sec:bintree-traversal]{обход деревьев},
\hyperref[sec:tree-ins-del]{вставка, удаление} и поиск элементов (для упорядоченных деревьев).

\section{Алгоритмы обхода дерева (поиск в неупорядоченном дереве)}
\label{sec:tree-traversal}

\subsection{Поиск в ширину (BFS)}
Этот алгоритм раскрывает дерево слой за слоем:
сперва посещается корень, затем его дети, за ними ---
все их дети, и так далее. Алгоритм BFS имеет сложность $O(n)$ требует
$O(n)$ дополнительной памяти.
\begin{algorithmic}
\Procedure{BFS}{Node $n$}
  \State $q$ \asgn empty Queue
  \State $q$.\Call{Enqueue}{$n$}
  \While{$q$ is not empty}
    \State $n$ \asgn $q$.\Call{Dequeue}{}
    \State Process $n$.data
    \ForAll{children $m$ of $n$}
      $q$.\Call{Enqueue}{$m$}
    \EndFor
  \EndWhile
\EndProcedure
\end{algorithmic}

\subsection{Поиск в глубину (DFS)}
Алгоритм DFS раскрывает дерево по веткам: сперва он доходит от корня до листа,
обрабатывая все посещенные вершины, затем он возвращается наверх, аналогичным
образом обрабатывая нераскрытые ветви. Вычислительная трудоемкость алгоритма
DFS такая же, как у BFS, однако для сбалансированных деревьев он требует $O(\log n)$
дополнительной памяти.
Реализацию DFS можно получить путем замены в алгоритме BFS очереди на стек:
\begin{algorithmic}
\Procedure{DFS}{Node $n$}
  \State $q$ \asgn empty Stack
  \State $q$.\Call{Push}{$n$}
  \While{$q$ is not empty}
    \State $n$ \asgn $q$.\Call{Pop}{}
    \State Process $n$.data
    \ForAll{children $m$ of $n$}
      $q$.\Call{Push}{$m$}
    \EndFor
  \EndWhile
\EndProcedure
\end{algorithmic}

Существует также рекурсивная реализация DFS, которая в качестве стека использует
стек вызовов.
\begin{algorithmic}
\Procedure{DFSRecursive}{Node $n$}
  \State Process $n$.data
  \ForAll{children $m$ of $n$}
    \State \Call{DFSRecursive}{$m$}
  \EndFor
\EndProcedure
\end{algorithmic}

\subsection{Обход бинарных деревьев}
\label{sec:bintree-traversal}
Для бинарных деревьев вводят несколько подвидов поиска в глубину,
которые определяют конкретный порядок посещения и обработки узла и его поддеревьев.

Алгоритм обхода в \textbf{прямом порядке} (Pre-order, NLR) обрабатывает узел перед
посещением поддеревьев.
\begin{algorithmic}
  \Function{PreOrder}{Node n}
    \State Process n
    \Comment{Обработать n}
    \If{n has left child}
      \State \Call{PreOrder}{n.left}
      \Comment{Посетить левое поддерево}
    \EndIf
    \If{n has right child}
      \State \Call{PreOrder}{n.right}
      \Comment{Посетить правое поддерево}
    \EndIf
  \EndFunction
\end{algorithmic}

Алгоритм обхода в \textbf{обратном порядке} (Post-order, LRN) обрабатывает узел после
посещения поддеревьев.
\begin{algorithmic}
  \Function{PostOrder}{Node n}
    \If {n has left child}
      \State \Call{PostOrder}{n.left}
    \EndIf
    \If{n has right child}
      \State \Call{PostOrder}{n.right}
    \EndIf
    \State Process n
  \EndFunction
\end{algorithmic}

Алгоритм обхода в \textbf{симметричном порядке} (In-order, LNR) обрабатывает узел между
посещениями поддеревьев. Если дерево является BST, то элементы обрабатываются в отсортированном
порядке.
\begin{algorithmic}
  \Function{InOrder}{Node n}
    \If {n has left child}
      \State \Call{InOrder}{n.left}
    \EndIf
    \State Process n
    \If{n has right child}
      \State \Call{InOrder}{n.right}
    \EndIf
  \EndFunction
\end{algorithmic}

\section{Добавление и удаление элементов дерева}
\label{sec:tree-ins-del}
