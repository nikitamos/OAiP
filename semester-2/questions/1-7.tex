\section{Концепция процедурного, модульного, структурного программирования}
\section{Простые (скалярные) типы данных. Представление целых чисел и чисел с фиксированной точкой. Машинная арифметика}
\section{Форматы представления чисел с плавающей точкой. Диапазоны значений, точность представления}
\section{Машинная арифметика для чисел с плавающей точкой. Точность представления и погрешности вычислений}
\section{Составные (структурированные) типы данных: массивы, структуры, объединения и битовые поля (C/C++), строки, файлы}
\section{Указатели и ссылки. Арифметика указателей}
\subsection{Указатели}

Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций. Как и ссылки, указатели применяются для косвенного доступа к объекту. Однако в отличие от ссылок указатели обладают большими возможностями.

\vspace{\baselineskip}

\noindent Определение указателя:
\begin{minted}{C++}
тип_данных *название_указателя;
// либо тип_данных* название_указателя;
\end{minted}

Cтоит отметить что положение звездочки (\mverb{*}) не влияет на определение указателя: ее можно помещать ближе к типу данных, либо к имени переменной - оба определения будут равноценны.

Также стоит отметить, что размер значения указателя (хранимый адрес) не зависит от типа указателя. Он зависит от конкретной платформы. На 32-разрядных платформах размер адресов равен 4 байтам, а на 64-разрядных - 8 байтам.

С помощью операция \mverb{&} можно получить адрес некоторого объекта, например, адрес переменной. Затем этот адрес можно присвоить указателю.

\vspace{\baselineskip}

\noindent\underline{Пример}:
\begin{minted}{C++}
int num = 42;
int *pnum = &num; // взятие адреса переменной num
*num = 24; // разыменовывание указателя 
int temp = *num;
std::cout << temp << '\n'; // 24
\end{minted}

\subsubsection{Умные указатели}

\textbf{Smart pointers} или "интеллектуальные указатели" -- это объекты, которые имитируют стандартные указатели: они также содержат адрес (как правило, адрес выделенной динамической памяти), и их можно также использовать для обращения к объектам по этому адресу. Но главное их отличие от стандартных указателей состоит в том, что нам не надо беспокоиться об освобождении памяти с помощью операторов \mverb{delete} или \mverb{delete[]}. Вся выделенная память, используемая интеллектуальными указателями, будет освобождаться автоматически, когда она станет не нужна. Соответственно это означает, что мы не столкнемся с утечками памяти, не соответствием между выделениями и освобождениями памяти и болтающимися указателями. Таким образом, smart-указатели позволяют упростить и обезопасить управление памятью. Типы интеллектуальных указателей определены в модуле memory стандартной библиотеки языка С++ и доступны в пространстве имен \texttt{std}.

В C++11 появилось три типа умных указателей, все они определены в заголовке из Стандартной библиотеки:
\begin{itemize}
    \item \mverb{std::unique_ptr} — умный указатель, владеющий динамически выделенным ресурсом;
    \item \mverb{std::shared_ptr} — умный указатель, владеющий разделяемым динамически выделенным ресурсом. Несколько \mverb{std::shared_ptr} могут владеть одним и тем же ресурсом, и внутренний счетчик ведет их учет;
    \item \mverb{std::weak_ptr} — подобен \mverb{std::shared_ptr}, но не увеличивает счетчик.
\end{itemize}

Если вы хотите понять как работать с умными указателями на базовом уровне, рекомендую данную \href{https://habr.com/ru/companies/piter/articles/706866/}{статью на Habr}.

\subsection{l-value и r-value}

\begin{itemize}
    \item
          В языке C++, все переменные являются l-values, l-value, то есть они имеют свой собственный адрес в памяти. l от слова «left», так как только значения l-values могут быть использованы в качестве операнда в левой части операции присваивания(в противоположном случае, мы получим ошибку), а также в других контекстах, где требуется изменяемое значение.
    \item
          Противоположностью l-value является r-value. r-value - это выражение, которое имеет временное значение, которое не может быть использовано в качестве операнда в левой части операции присваивания. Например, число \mverb{42} или результат выражения \mverb{42 + х} являются r-values. Они не имеют адреса в памяти и не могут быть изменены. Обычно r-value используется в качестве операнда в правой части операции присваивания и других контекстах, где требуется неизменяемое значение.
    \item
          x-values (eXpiring values) - это категория значений, которая была введена в C++11 для представления объектов, которые находятся в конце своего жизненного цикла и могут быть перемещены в другой объект. Они представляют собой изменяемые r-values, но не имеют адреса в памяти. Примерами x-values могут быть объекты, которые были созданы с помощью функции \mverb{std::move()} или которые являются результатом выражения \mverb{std::move()};
\end{itemize}

\href{https://en.cppreference.com/w/cpp/language/value_category.html}{Cppreference - Value categories}

\subsection{Ссылки}

В C роль ссылок играют указатели, но работать с ними не очень удобно и в C++ появилась отдельная сущность — ссылка (reference). В C++11 ссылки получили дальнейшее развитие, появились rvalue-ссылки, универсальные (передаваемые) ссылки, которые играют ключевую роль в реализации семантики перемещения — одном из самых значительных нововведений C++11.

\begin{minted}{C++}
T x;
T &rx = x; // определение ссылки
T &rx2 = rx; // определение копии ссылки
\end{minted}

Инициализация ссылки обязательна, нулевые ссылки (ссылки на «ничто») не поддерживаются. Изменить переменную, на которую ссылается ссылка, невозможно. Таким образом, ссылка является константной сущностью, хотя формально ссылочный тип не является константным.

Собственных операций ссылка не поддерживает, все операторы, примененные к ссылке, на самом деле применяются к переменной, на которую она ссылается. Это касается и таких операторов, как \mverb{=} (присваивание), \mverb{&} (получение адреса), \mverb{sizeof}, \mverb{typeid}. Но вот спецификатор \mverb{decltype}, если его применить к ссылке, дает ссылочный тип.

Если T некоторый неконстантный и нессылочный тип или псевдоним, то можно определить ссылку на константу. Через ссылку на константу нельзя модифицировать объект, на которой она ссылается. Это означает, что для встроенных типов через такую ссылку запрещено присваивание, инкремент, декремент, а для пользовательских типов запрещен вызов неконстантных функций-членов.

\subsubsection*{Ссылки r-value}

В C++11 был добавлен новый тип ссылок - \textbf{ссылки r-value}, которые позволяют получать доступ к r-values и x-values. Они используются для реализации семантики перемещения и эффективной передачи аргументов функций. В то время как ссылка l-value создается с использованием одного амперсанда, ссылка r-value создается с использованием двойного амперсанда:

\begin{minted}{C++}
int &&rref = 42; // инициализация ссылки r-value литералом 42 (значение r-value)
\end{minted}

\href{https://habr.com/ru/articles/646005/}{Достаточно подробная статья о ссылках}

\subsection{Арифметика указателей}
\textit{Одноименными} будем называть указатели, которые указывают на переменные
одинакового типа. По стандарту арифметические операции нельзя совершать над 
указателями на \verb|void|\footnote{точнее, на неполные типы (incomplete types ---
types that describe objects but lack information needed to determine their sizes)}
и функции, хотя GCC разрешает эти операции в качестве расширения.

К арифметическим операциям над указателями относятся следующие операции:
\begin{enumerate}
  \itembf{Сложение с числом.} К указателю можно прибавлять как положительные,
  так и отрицательные числа. Эта операция коммутативна. При прибавлении к указателю
  \verb|a| числа \verb|n|, значение адреса памяти, на который указывает указатель,
  увеличивается на \verb|n*sizeof(*a)|. Таким образом, указатель сдвигается на одну или
  несколько ячеек.

  Выражение \verb|*(a + n)| также можно записывать как \verb|a[n]|.
  С точки зрения языка обе записи эквивалентны.
  
  Пример операции:
\begin{minted}{cpp}
int n = 4;
if (((unsigned long)(a + n)) == ((unsigned long)a) + (n * sizeof(int))) {
  std::cout << "OK\n";
}
// Вывод программы: OK
\end{minted}

  \itembf{Инкремент и декремент} прибавляет и отнимает единицу к указателю (\textbf{не} к адресу!) по правилу, указанному
  выше, соответственно. При этом, как и с обычными числами, префиксные операторы возвращают измененное
  значение, а постфиксные --- неизмененное.

  Следует обратить внимание на приоритет оператора инкремента (декремента)
  и оператора разыменования \verb|*|. При использовании как префиксного, так и постфиксного
  оператора сначала выполнится инкремент (декремент) и только потом --- разыменование.
\begin{minted}{cpp}
int c[2]{5, 10};
int *b = c;
// 5 (b до изменения указывает на c[0])
std::cout << *b++ << '\n';
// Теперь b указывает на c[1]
// 10 | 5 10
std::cout << *b << " | " << c[0] << ' '
                          << c[1] << '\n';
\end{minted}

  \itembf{Вычитание числа из указателя} работает так же, как и прибавление к указателю
  числа, противоположного по знаку.
  \itembf{Вычитание одноименных указателей} \verb|a - b| возвращает такое число \verb|n|,
  что \verb|a == b + n|. Число \verb|n| имеет тип \mverb{ptrdiff_t} из \mverb{<cstddef>},
  который является \mverb{typedef}'ом от какого-то\footnote{implementation-defined} базового
  \textit{знакового} целочисленного типа.
\begin{minted}{cpp}
int a[20]{};
int *b = a;
int *c = a + 12;
// 12
std::cout << c - b << '\n';
// -12
std::cout << b - c << '\n';
\end{minted}
  Если результат вычитания настолько большой, что не может поместиться в \mverb{ptrdiff_t},
  то UB.
\end{enumerate}

\section{Строковый тип в C++. Представление в памяти. Автоматическое управление памятью для Си строк и std::string}
В языке C++ работа со строками может осуществляться двумя принципиально разными способами: с использованием классических C-строк и через класс \mverb{std::string} из 
стандартной библиотеки. C-строки представляют собой массивы символов типа char, которые обязательно завершаются нуль-терминатором (`\verb|\0|'). Такое представление унаследовано из 
языка C и хранится в памяти как последовательность байт с явным указателем на начало строки. Основная проблема C-строк заключается в необходимости ручного управления памятью
~-- разработчик должен самостоятельно выделять достаточный объем памяти под строку, следить за переполнением буфера и освобождать ресурсы. Это не только неудобно, но и 
потенциально опасно, так как ошибки в работе с памятью могут приводить к уязвимостям безопасности.

В отличие от этого, класс \mverb{std::string} предоставляет современный и безопасный способ работы со строками. Внутри он использует динамически выделяемую память, 
автоматически расширяя буфер при необходимости. Объект \mverb{std::string} хранит не только сами символьные данные, но и дополнительную служебную информацию -- текущий 
размер строки и емкость выделенного буфера. Это позволяет эффективно управлять памятью и избегать частых перераспределений. Важнейшее преимущество \mverb{std::string} -- 
автоматическое освобождение памяти при выходе объекта из области видимости.

С точки зрения удобства работы \mverb{std::string} также значительно превосходит C-строки. Стандартная библиотека предоставляет богатый набор методов для манипуляции 
строками: поиск подстрок, вставка и удаление символов, конкатенация через оператор \verb|+| и многое другое. При этом все операции безопасны с точки зрения работы с памятью. 
В современных проектах на C++ рекомендуется повсеместно использовать \mverb{std::string}, оставляя C-строки только для случаев, когда требуется совместимость с 
унаследованным кодом или внешними C-библиотеками. Переход на \mverb{std::string} позволяет писать более надежный, читаемый и поддерживаемый код, избавляя разработчика от 
многих потенциальных ошибок, связанных с ручным управлением памятью.

Важно отметить, что \mverb{std::string} не является абсолютно идеальным решением для всех случаев. В высокопроизводительных системах, где критически важна скорость работы и 
минимальные накладные расходы, иногда предпочтительнее использовать более низкоуровневые подходы. Однако для подавляющего большинства приложений преимущества \mverb{std::string}
-- автоматическое управление памятью, безопасность и удобство интерфейса -- с лихвой перевешивают возможные микрооптимизации, которые можно получить при работе с C-строками.

Вообще говоря, в C++ \cppref[строки]{cpp/string/basic_string} предоставляют более общий функционал.

Класс \mverb{std::basic_string<T, CharTratis, Alloc>} инкапсулирует произвольные последовательности
обобщенных символов, которые заканчиваются нуль-терминатором\footnote{При желании терминальный символ можно
переопределить с помощью второго шаблонного параметра}. Псевдонимом данного класса с определенными значениями
шаблонных аргументов является упомянутый выше класс \mverb{std::string},
инкапсулирующий последовательности символов \mverb{char}. Обычно реализации
стандартной библиотеки содержат т.н. SSO (short string optimization), которая позволяет хранить короткие строки на стеке.

Класс \mverb{basic_string} (с учетом опускания второго шаблонного параметра) имеет следующее представление в памяти:
\begin{minted}{C++}
// Пример, иллюстрирующий представление std::basic_string
// в стандартной библиотеке GCC.
template <typename CharT, typename Alloc>
class basic_string {
private:
  // Максимальное число нетерминальных символов на стеке
  static constexpr const size_t kMaxLocalChars = (15 / sizeof(CharT));

  // Структура, которая объединяет в себя аллокатор и указатель на
  // выделенный на куче буфер.
  // Почему так? Зачем наследование? Не знаю, умным людям виднее.
  struct _Alloc_hider : Alloc {
    CharT *heap_buf_;
  };

  _Alloc_hider alloc_;
  // Размер самой строки
  size_t size_;

  // Поскольку строка располагается или только в куче, или только на
  // стеке, зная размер size_, мы можем определить, какое поле объединения
  // надо использовать
  union {
    // Массив символов, хранящийся на стеке. Один дополнительный символ для 
    // нулевого терминатора
    CharT local_buf_[kMaxLocalChars + 1];
    // Размер буфера, выделенного на куче.
    size_t capacity;
  };
};
\end{minted}