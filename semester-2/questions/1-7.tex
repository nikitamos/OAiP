\section{Концепция процедурного, модульного, структурного программирования}
\section{Простые (скалярные) типы данных. Представление целых чисел и чисел с фиксированной точкой. Машинная арифметика}
\section{Форматы представления чисел с плавающей точкой. Диапазоны значений, точность представления}
\section{Машинная арифметика для чисел с плавающей точкой. Точность представления и погрешности вычислений}
\section{Составные (структурированные) типы данных: массивы, структуры, объединения и битовые поля (C/C++), строки, файлы}
\section{Указатели и ссылки. Арифметика указателей}
\section{Строковый тип в C++. Представление в памяти. Автоматическое управление памятью для Си строк и std::string}
В языке C++ работа со строками может осуществляться двумя принципиально разными способами: с использованием классических C-строк и через класс \mverb{std::string} из 
стандартной библиотеки. C-строки представляют собой массивы символов типа char, которые обязательно завершаются нуль-терминатором (`\verb|\0|'). Такое представление унаследовано из 
языка C и хранится в памяти как последовательность байт с явным указателем на начало строки. Основная проблема C-строк заключается в необходимости ручного управления памятью
~-- разработчик должен самостоятельно выделять достаточный объем памяти под строку, следить за переполнением буфера и освобождать ресурсы. Это не только неудобно, но и 
потенциально опасно, так как ошибки в работе с памятью могут приводить к уязвимостям безопасности.

В отличие от этого, класс \mverb{std::string} предоставляет современный и безопасный способ работы со строками. Внутри он использует динамически выделяемую память, 
автоматически расширяя буфер при необходимости. Объект \mverb{std::string} хранит не только сами символьные данные, но и дополнительную служебную информацию -- текущий 
размер строки и емкость выделенного буфера. Это позволяет эффективно управлять памятью и избегать частых перераспределений. Важнейшее преимущество \mverb{std::string} -- 
автоматическое освобождение памяти при выходе объекта из области видимости.

С точки зрения удобства работы \mverb{std::string} также значительно превосходит C-строки. Стандартная библиотека предоставляет богатый набор методов для манипуляции 
строками: поиск подстрок, вставка и удаление символов, конкатенация через оператор \verb|+| и многое другое. При этом все операции безопасны с точки зрения работы с памятью. 
В современных проектах на C++ рекомендуется повсеместно использовать \mverb{std::string}, оставляя C-строки только для случаев, когда требуется совместимость с 
унаследованным кодом или внешними C-библиотеками. Переход на \mverb{std::string} позволяет писать более надежный, читаемый и поддерживаемый код, избавляя разработчика от 
многих потенциальных ошибок, связанных с ручным управлением памятью.

Важно отметить, что \mverb{std::string} не является абсолютно идеальным решением для всех случаев. В высокопроизводительных системах, где критически важна скорость работы и 
минимальные накладные расходы, иногда предпочтительнее использовать более низкоуровневые подходы. Однако для подавляющего большинства приложений преимущества \mverb{std::string}
-- автоматическое управление памятью, безопасность и удобство интерфейса -- с лихвой перевешивают возможные микрооптимизации, которые можно получить при работе с C-строками.

Вообще говоря, в C++ \cppref[строки]{cpp/string/basic_string} предоставляют более общий функционал.

Класс \mverb{std::basic_string<T, CharTratis, Alloc>} инкапсулирует произвольные последовательности
обобщенных символов, которые заканчиваются нуль-терминатором\footnote{При желании терминальный символ можно
переопределить с помощью второго шаблонного параметра}. Псевдонимом данного класса с определенными значениями
шаблонных аргументов является упомянутый выше класс \mverb{std::string},
инкапсулирующий последовательности символов \mverb{char}. Обычно реализации
стандартной библиотеки содержат т.н. SSO (short string optimization), которая позволяет хранить короткие строки на стеке.

Класс \mverb{basic_string} (с учетом опускания второго шаблонного параметра) имеет следующее представление в памяти:
\begin{minted}{C++}
// Пример, иллюстрирующий представление std::basic_string
// в стандартной библиотеке GCC.
template <typename CharT, typename Alloc>
class basic_string {
private:
  // Максимальное число нетерминальных символов на стеке
  static constexpr const size_t kMaxLocalChars = (15 / sizeof(CharT));

  // Структура, которая объединяет в себя аллокатор и указатель на
  // выделенный на куче буфер.
  // Почему так? Зачем наследование? Не знаю, умным людям виднее.
  struct _Alloc_hider : Alloc {
    CharT *heap_buf_;
  };

  _Alloc_hider alloc_;
  // Размер самой строки
  size_t size_;

  // Поскольку строка располагается или только в куче, или только на
  // стеке, зная размер size_, мы можем определить, какое поле объединения
  // надо использовать
  union {
    // Массив символов, хранящийся на стеке. Один дополнительный символ для 
    // нулевого терминатора
    CharT local_buf_[kMaxLocalChars + 1];
    // Размер буфера, выделенного на куче.
    size_t capacity;
  };
};
\end{minted}