\section{Файлы. Двоичные и текстовые форматы файлов. Файлы прямого и последовательного доступа. Стандартные файлы (потоки)}
\section{Потоки ввода-вывода (C++). Работа с файлами посредством потоков}
\subsection{Поток}
\cppref[\textbf{Поток}]{cpp/io}~--- абстрактное устройство ввода/вывода, позволяющее в общем виде манипулировать содержимым файлов, данными устройств ввода/вывода,
межпроцессными конвейерами и т.д., а также произвольными абстрактными устройствами, выполняющими операции <<на лету>> (например сжатие информации).
О потоке также можно судить как об абстрактной последовательности байт (символов или чего бы то ни было еще).

В языке C++ предоставляются несколько интерфейсов для работы с потоками произвольной природы:
\begin{itemize}
    \item \cppref[Библиотека потокового ввода/вывода в ООП-стиле]{cpp/io\#Stream-based_I.2FO};
    \item \href{https://en.cppreference.com/w/cpp/io.html#Print_functions_.28since_C.2B.2B23.29}{Библиотека на основе \texttt{print()} (с С++ 23)};
    \item \cppref[Ввод-вывод в стиле С]{cpp/op/c}.
\end{itemize}

Рассмотрим основные компоненты ООП-библиотеки языка C++.

\subsection{Построение библиотеки потокового ввода-вывода}
Рассматриваемая библиотека разделена на модули, которые отвечают за различный функционал.

\begin{enumerate}
    \item Абстракции~--- составляют основные шаблонные классы для взаимодействия с любыми потоками, буферизированными и нет.
    \item Ввод/вывод файлов~--- предоставляют высокоуровневые обертки и низкоуровневую реализацию файловых потоков.
    \item Ввод/вывод строк и массивов~--- предоставляют высокоуровневые обертки и низкоуровневую реализацию потоков из участков оперативной памяти.
          % \item (С С++ 20) Синхронизированный вывод~--- предоставляет примитивы для работы с потоками вывода, с дополнительными требованиями к синхронизации
          %       в многопоточном контексте.
    \item Предопределенные потоки устройств ввода/вывода~--- \mverb{std::cin}, \mverb{std::cout}, \mverb{std::cerr} (небуферизирован), \mverb{std::clog} (буферизирован)\footnotemark.
    \item Псевдонимы наиболее распространенных типов (например \mverb{std::fstream} является псевдонимом к типу \mverb{std::basic_fstream<char>}).
    \item Манипуляторы ввода/вывода~--- позволяют управлять состояниями потока а также форматированием посылаемых в него
          данных (например, функция\mverb{std::setprecision(int n)}, предоставляемая заголовком \mverb{<iomanip>}).
\end{enumerate}

\footnotetext{В Unix все~--- файл, и это относится к потокам ввода/вывода. Говоря конкретнее (стандарт \href{https://pubs.opengroup.org/onlinepubs/9799919799/}{POSIX}), каждый запущенный процесс (кроме, быть может,
    демона -- фоновой службы) обладает тремя файловыми дескрипторами: \texttt{0} для стандартного ввода, \texttt{1} для стандартного вывода и
    \texttt{2} для стандартного потока ошибок.}

\subsection{Работа с файлами}
Рассмотри основные операции с файлами в С++ с использованием библиотеки потоков ввода/вывода.

Функциональность для работы с файлами предоставляют шаблоны из заголовочного файла \mverb{<fstream>}. Чаще всего необходимая работа обеспечивается
классами \mverb{std::ifstream} (файлы <<только на чтение>>), \mverb{std::ofstream} (файлы <<только на запись>>) и \mverb{std::fstream} (универсальный).

Для открытия файлов используется метод \mverb{open(filename, mode)}, где параметр \mverb{mode} определяет режим открытия файла путем
выставления флагов:

\begin{center}
    \begin{tabular}{c|p{0.5\textwidth}}
        Флаг                     & Пояснение                                                                              \\
        \hline
        \mverb{std::ios::in}     & Для чтения                                                                             \\
        \mverb{std::ios::out}    & Для записи                                                                             \\
        \mverb{std::ios::binary} & В двоичном режиме (каждый байт интерпретируется <<как есть>>)                          \\
        \mverb{std::ios::ate}    & Указатель в файл устанавливается в конец (по умолчанию~--- в начало)                   \\
        \mverb{std::ios::app}    & Все операции производятся в конце файла, \textit{дописывая} к его содержимому          \\
        \mverb{std::ios::trunc}  & Если файл уже существует и открывается для записи, все предыдущее содержимое стирается \\
    \end{tabular}
\end{center}

Флаги объединяются при помощи оператора <<побитовое ИЛИ>>.

В случае успеха, метод \mverb{is_open()} вернет \mverb{true}.
Пример:
\begin{minted}{cpp}
std::ofstream myfile;
myfile.open("example.bin", ios::out | ios::app | ios::binary);
if (!myfile.is_open()) {
    std::cerr << "Ошибка открытия файла.";
}
\end{minted}

Закрытие файла выполняется методом \mverb{close()}. Впрочем, деструктор объекта потока при необходимости сделает это автоматически.

Для чтения или записи данных в поток применяется стандартный интерфейс всей библиотеки потоков С++, а именно перегруженные операторы
\mverb{operator<<} и \mverb{operator>>} для форматированных (обычно текстовых) данных, а также методы \mverb{write(memory_block, size)} и
\mverb{read(memory_block, size)} для, соответственно, неформатированных (обычно бинарных) данных.

\subsection{Указатель в файле}
Каждый открытый файл имеет по крайней мере один так называемый указатель на текущую позицию в файле. В зависимости от возможностей объекта потока, существуют
указатель чтения (\textbf{get position}) и указатель записи (\textbf{put position})\footnote{\texttt{std::ifstream} содержит только \textit{get position}, \texttt{std::ofstream}~--- только \textit{put position},
    а \texttt{std::fstream} содержит оба, причем они могут не совпадать.}.  Для работы с указателями в файле предоставляются базовые операции:

\begin{itemize}
    \item \mverb{tellg()} и \mverb{tellp()}~--- возвращают текущее значение указателя в файл в виде объекта типа \mverb{std::streampos}.
    \item \mverb{seekg(position)}, \mverb{seekg(offset, direction)}, \mverb{seekp(position)} и \mverb{seekp(offset, direction)}~-- манипулируют
          указателем в файле. Перегрузки с одним аргументом устанавливают абсолютное значение, с двумя~--- относительное.

          Относительное позиционирование может выполнятся по-разному, в зависимости от аргумента \texttt{direction}:

          \begin{center}
              \begin{tabular}{
                  >{\raggedright\arraybackslash}p{0.25\linewidth}
                  | >{\raggedright\arraybackslash}p{0.25\linewidth}}
                  Значение              & Направление         \\
                  \hline
                  \mverb{std::ios::beg} & С начала файла      \\
                  \mverb{std::ios::cur} & С текущего значения \\
                  \mverb{std::ios::end} & С конца файла       \\
              \end{tabular}
          \end{center}
\end{itemize}

\section{Основы объектно-ориентированного программирования: классы, объекты, методы}
\section{Основы объектно-ориентированного программирования: инкапсуляция, наследование, полиморфизм}
\section{Сложность алгоритмов (временнАя и пространственная). Оценки сложности}
\section{Вызов функций (методов). Передача параметров и возврат результата. Рекурсия}
\section{Статическое и динамическое выделение памяти. "Куча"}
