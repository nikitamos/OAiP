\documentclass[12pt, a4paper]{extarticle}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{multirow}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{listing}
\usepackage{pdfpages}
\usepackage[inline]{enumitem}

\newlist{enuminl}{enumerate*}{1}
\setlist[enuminl]{label=(\arabic*)}

\begin{document}
\title{Ответы по ОАиПу \\ {\large \textit{Вопросы 37-54 \\ C'est la fin.}}}
\date{}

\clearpage\maketitle
\thispagestyle{empty}

\newcommand{\itembf}[1]{\item \textbf{#1}}

\newpage
\tableofcontents
\newpage

\setcounter{section}{36}

\section{Операции над указателями разного порядка}
Над указателями можно проводить следующие операции:
\begin{enumerate}
  \item Присваивание \verb|=|. Работает так же, как и с обычными переменными:
  операция \verb|a = b| запишет в указатель \verb|a| значение указателя \verb|b|
  и вернет записанное значение. Присваивание разрешено только если оба операнда одноименные
  или один из них является указателем на \verb|void|. С данными, на которые указывал \verb|a|,
  ничего не будет. Если на эти данные не было других указателей, то доступ к ним будет
  утерян и освобождения памяти не последует.
  \item Разыменование \verb|*| возвращает тот объект, на который указывает указатель.
  \begin{verbatim}
int *a = 4;
// 4
std::cout << a << '\n';
*a += 7;
// 11
std::cout << *a << '\n';
  \end{verbatim}
  \item Взятие адреса самой перменной, которая является указателем \verb|&| возвращает указатель
  на указатель (то есть указатель высшего порядка):
  \begin{verbatim}
int a = 13;
int *b = &a;
int **c = &b;
int ***d = &c;
// ...
// Можно продолжать сколько угодно

// 13
std::cout << **c << '\n';
// Два одинаковых числа
std::cout << *d << ' ' <<c << '\n';
  \end{verbatim}
  \item Сравнение значений указателей \verb|<, <=, >, >=, ==, !=|. Адреса, на которые
  указыввают сравниваемые указатели сравниваются как обычные целые числа.
  \item \hyperref[sec:ptr_arithm]{Арифметические операции}.
\end{enumerate}

Все эти операции работают для указателей любого порядка.

Указатели высших порядков обычно используются в для представления многомерных
массивов\footnote{адекватные люди (если они программируют не микроконтроллеры)
для этого используют вложенные \mbox{std::vector}}.
Для получения конкретного элмента $n$-мерного массива достаточно $n$ раз
применить оператор \verb|[]|\footnote|или сложения с разыменованиями, если вы желаете страдать|.

Перебор многомерных массивов осуществляется с помощбю вложенных циклов
Ниже приведен пример сложения матриц.

\begin{verbatim}
/// Складывает матрицы `lhs` и `rhs` размера `m * n`.
/// Результат записывает в матрицу `res`.
void AddMatrices(int **lhs, int **rhs, int **res,
                 int m, int n)
{
  for (int i = 0; i < m; ++m) {
    for (int j = 0; j < n; ++j) {
      // Вместо того, что в левой части
      // для доступа к элементам массива `res`
      // можно использовать выражение `res[i][j]`
      *(*(res + i) + j) = lhs[i][j] + rhs[i][j];
    }
  }
}
\end{verbatim}

\section{Арифметика указателей}
\label{sec:ptr_arithm}
\textbf{Указатель} --- переменная, значением которой является адрес памяти.
В памяти указатель представляется как беззнаковое целое длины, равной длине
машинного слова.
\textit{Одноименными} будем называть указатели, которые указывают на переменные
одинакового типа. По стандарту арифметические операции нельзя совершать над 
указателями на \verb|void|\footnote{точнее, на неполные типы (incomplete types ---
types that describe objects but lack information needed to determine their sizes)}
и функции, хотя GCC разрешает эти операции в качестве расширения.

К арифметическим операциям над указательями относятся следующие операции:
\begin{enumerate}
  \itembf{Сложение с числом.} К указателю можно прибавлять как положительные,
  так и отрицательные числа. Эта операция коммутативна. При прибавлении к указателю
  \verb|a| числа \verb|n|, значение адреса памяти, на котороый указвает указатель,
  увеличивается на \verb|n*sizeof(*a)|. Таким образом, указатель сдвигается на одну или
  несколько ячеек.

  Выражение \verb|*(a + n)| также можно записывать как \verb|a[n]|.
  С точки зрения языка обе записи эквивалентны.
  Пример (выведет \verb|OK|):
\begin{verbatim}
int n = 4;
if (((unsigned long) (a+n)) ==
    ((unsigned long) a) + (n*sizeof(int))) {
      std::cout << "OK\n";
}
\end{verbatim}

  \itembf{Инкремент и декремент} прибавляет и отнимает единицу к указателю (\textbf{не} к адресу!) по правилу, указанному
  выше, соответственно. При этом, как и с обычными чисами, префиксные операторы возвращают измененное
  значение, а постфиксные --- неизмененное.

  Единственное, следует обратить внимание на приоритет оператора инекремента (декремента)
  и оператора разыменования \verb|*|. При использовании как префиксного, так и постфиксного
  оператора сначала выполнится инкремент (декремент) и только потом --- разыменование.
\begin{verbatim}
int c[2]{5, 10};
int *b = c;
// 5 (b до изменения указывает на c[0])
std::cout << *b++ << '\n';
// Теперь b указывает на c[1]
// 10 | 5 10
std::cout << *b << " | " << c[0] << ' '
                          << c[1] << '\n';
\end{verbatim}

  \itembf{Вычитание числа из указателя} работает так же, как и прибавление к указателю
  числа, противоположного по знаку.
  \itembf{Вычитание одноименных указателей} \verb|a - b| возвращает такое число \verb|n|,
  что \verb|a == b + n|. Число \verb|n| имеет тип \verb|ptrdiff_t| из \verb|<cstddef>|,
  который является \verb|typedef|'ом от какого-то\footnote{implementation-defined} базового
  \textit{знакового} целочисленного типа.
\begin{verbatim}
int a[20]{};
int *b = a;
int *c = a + 12;
// 12
std::cout << c - b << '\n';
// -12
std::cout << b - c << '\n';
\end{verbatim}
  Если результат вычитания настолько большой, что не может поместиться в \verb|ptrdiff_t|,
  то UB.
\end{enumerate}

\section{Массивы переменных размеров. Аллокаторы памяти}
\textbf{Массив} — это определённое число ячеек памяти, расположенных непосредственно друг за другом.
Массив позволяет хранить несколько значений одинакового типа.

Поскольку число элементов массива переменной длины и, следовательно, его размер заранее неизвестны,
память для него обычно выделяется в куче. Доступ к элементам массива при этом осуществляется через
указатель на первый элемент массива при помощи арифметики указателей или оператора \verb|[]|

В языке C++ память можно выделять двумя основными способами:
\begin{enumerate}
  \item Функциии \verb|malloc, realloc, calloc|.
  Для первоначального выделения памяти можно использовать любую из этих функций.
  Для изменения размера выделенного участка памяти необходимо использовать 
  функцию \verb|realloc|. Она либо расширяет старый участок памяти, либо выделяет память
  заново, копирую при этом туда нужное число элементов (минимум от старого и нового размеров) и
  освобждая после этого старый участок.

  \begin{verbatim}
// Выделение памяти
int *array = (int*) malloc(sizeof(int) * array_size);

// Изменение размера
array = (int*) realloc(sizeof(int) * new_array_size);

// Освобождение памяти
free(array);
  \end{verbatim}
  
  \item Оператор \verb|new[]|
  Оператор \verb|new type[x]| позволяет выделети динамический массив из \verb|x|
  элементов типа \verb|type|, вызывая для каждого элемента конструктор по умолчанию.
  Для освобождения выделенного массива используется операвтор \verb|delete[]|, который
  не только освободит память, но и вызовет деструкторы всех элементов массива.

  Язык C++ не предоставляет аналога функции \verb|realloc| из C. Поэтому для изменения размера массива
  необходимо выделить память заново и вручную переместить
  в новую область памяти существующие элементы массива.
  \begin{verbatim}
// Выделение памяти
int *array = new int[array_size];

// Изменение размера
int *new_array = new int[new_array_size];
int copy_size = std::min(array_size, new_array_size);
for (int i = 0; i < copy_size; ++i) {
  new_array[i] = array[i]; // Или std::move(array[i]);
}
delete[] array;
array = new_array;

// Освобождение памяти
delete[] array;
  \end{verbatim}
\end{enumerate}

Работа с памятью в стиле языка Си в некоторых случаях позволяет облегчить
перевыделение памяти, поскольку избегает копирования всех элементов массива,
однако возлагает на программиста ответственность за ручной вызов деструкторов
и placement new, если приходится работать с объектами производных типов.

\paragraph{Аллокатор} --- высокоуровневая абстракция над выделением и освобождением памяти,
которая позволяет задать конекретный способ того, как будет выделяться память. Аллокатор
должен предоставлять функционал выделения и освобождения выделенной им памяти.

Для непосредственного выделения памяти используются системные вызовы
\verb|mmap| на Linux; \verb|GlobalAlloc|, \verb|HeapAlloc| и др. на Windows.
Они требуют переключения контекста на процессоре и передают управление ядру ОС,
что является относительно дорогостоящей операцией. Из-за этого программисты обычно
стремятся уменьшить число системных вызовов.

В случае выделения памяти этого можно достичь, если, например, обращаться к системным вызовам
только для выделения достаточно больших участков памяти, которые распределяются уже функциями,
которые работают в пространстве пользователя.

Примерно такую стратегию используют функции \verb|*alloc| и оператор \verb|new|, поэтому
в широком смысле их можно назвать аллокаторами.

Наконец, отметим, что аллокатор в общем случае не обязан выделять память на куче или вообще использовать
системные вызовы. Ниже приведен пример примитивного аллокатора, который выделяет статическую память.

Он резервирует 100\,000 байт статической памяти и хранит размер
выделенной памяти, а вызове метода \verb|Allocate| возвращает указатель на участок
зарезрвированной при создании памяти и увеличивает значение переменной, хранящей
размер выделенной памяти.

Для простоты реализации этот аллокатор не может переиспользовать освобожденную память,
поэтому функция \verb|Deallocate|, которая должна освобождать участок памяти, ничего не
делает. Вся память, занятая аллокатором будет атоматически осовобождена при завершении исполнения прграммы.

\begin{verbatim}
#include <cmath>
#include <iostream>

struct StaticAllocator {
  static constexpr const size_t kPoolSize = 100'000;

  /// Выделяет память размером `size`'.
  /// В случае неудачи возвращает `nullptr`,
  /// иначе - указатель на выделенную память.
  void *Allocate(size_t size) {
    if (allocated_ + size <= kPoolSize) {
      void *result = pool_ + allocated_;
      allocated_ += size;
      return result;
    }
    return nullptr;
  }
  /// Освобождает выделенный указатель `ptr`
  void Deallocate(void *ptr) {
    /// nop
  }

private:
  char pool_[kPoolSize];
  size_t allocated_ = 0;
};

static StaticAllocator allocator;

int main() {
  // Массив из 3 int'ов
  int *a = (int *)allocator.Allocate(3 * sizeof(int));
  std::cin >> a[0];
  std::cin >> a[1];
  a[2] = a[0] + a[1];
  std::cout << a[2] << '\n';

  // Один double
  double *b = (double *)allocator.Allocate(sizeof(double));
  std::cin >> *b;
  std::cout << std::sqrt(*b) << '\n';

  // Освобождение памяти
  allocator.Deallocate(a);
  allocator.Deallocate(b);
}
\end{verbatim}

\section{Рекурсивные алгоритмы}
\textbf{Рекурсивная функция} -- такая функция, которая вызывает саму себя.
Тривиальным примером рекурсивной функции может служить функция для вычисления
чисел Фибоначчи, определяемых рекуррентным соотношением $f_n = f_{n-1} + f_{n-2} \quad (n \geq 3)$, причем $f_1 = f_2 = 1$:
\begin{verbatim}
long FibRecursion(long n) {
  if (n == 1 || n == 2) {
    return 1;
  }
  return FibRecursion(n - 1) + FibRecursion(n - 2);
}  
\end{verbatim}

Математически доказуемо, что любой рекурсивный алгоритм можно реализовать с помощью цикла
и обратно: любой циклический алгоритм можно реализовать с помощью рекурсии.

\begin{verbatim}
long FibLoop(long n) {
  long f1 = 1;
  long f2 = 1;
  for (int i = 1; i <= n; ++i) {
    f1 += f2;
    std::swap(f1, f2);
  }
  return f2;
}
\end{verbatim}

Рекурсия используется во многих алгоритмах, например в сортировках Quicksort и Mergesort,
в обходе графов (поиск в глубину).

Рекурсивные алгоритмы из-за накладных раходов на вызов функции обычно показывают худшую
производительность чем циклические, несмотря на одинаковую
асимптотику. Кроме того, для работы рекурсивных алгоритмов необходимо поддерживать стек вызовов.
Но размер стека ограничен, что накладывает ограничение на максимальную глубину рекурсии.

Из-за кривого дизайна (как в примере выше) выполнение рекурсивной функции может иметь
экспоненциальную сложность. Например, для вычисления 10-го числа Фибоначчи эта функция
два раза вычислит 8-ое число, для чего ей понадобится 4 раза вычислить 7-ое и т.\,д. Чтобы
избежать повторных вычислений, применяют подход, называемый \textbf{мемоизацией}: после вычисления
функции для заданного значения аргумента оно сохраняется в памяти, а при повторных запросах функция
возвращает уже вычисленное значение. Применение мемоизации позволяет снизить алгоритмическую сложность
до $O(n)$ (в данном примере), пожертвовав дополнительной памятью.

\begin{verbatim}
#include <cstdint.h>

uint64_t FibMem(uint64_t n) {
  // Число Фибоначчи F(94) уже не
  // помещается в uint64_t
  if (n >= 94) {
    return 0;
  }
  static uint64_t memory[95] {0};
  if (n == 1 || n == 2) {
    memory[n] = 1;
    return 1;
  }
  if (memory[n] == 0) {
    memory[n] = FibMem(n - 1) + FibMem(n - 2);
  }
  return memory[n];
}
\end{verbatim}

\section{Алгоритмы сортировки. Асимптотическая сложность}
\textbf{Сортировка} --- процесс расположения элементов массива (последовательности) в определенном
порядке, удобоном для работы. Если отсортировать массив чисел в порядке возрастания, то первый элемент
всегда будет наименьшим, а последний --- наибольшим.
Сортировки имеют важное прикладное значение. Например, с отсортированными данными иногда можно
работать более эффективно, чем с неупорядоченными (бинарный поиск имеет сложность $O(\log n)$, а
линейный --- $O(n)$).

Алгоритм сортировки называется \textbf{устойчивым} (stable), если он сохраняет порядок следования
элементов с совпадающим значением ключа --- признака, по которому происходит сравнение.

Алгоритмическая сложность многих алгоритмов сортировки может зависеть от входных данных
\footnote{Здесь и далее, если не указано иное, за $n$ принимается размер массива}.

Можно доказать, что асимптотическая сложность сортировки, основанной на сравнениях, не может
быть лучше, чем $O(n\cdot \log n)$. При этом существуют алгоритмы сортировки (например, Radix Sort и Bucket Sort),
которые используют знания о природе сортируемых данных и имеют сложность $O(n)$ в среднем, однако они могут быть
неприменимы в общем случае.

Ниже приведены и кратко описаны некоторые алгоритмы сортировки. Для простоты будем считать,
что мы сортируем массивы чисел по возрастанию.

\paragraph{Пузырьковая сортировка.} Самый примитивный алгоритм сортировки. Выполняет проходы по массиву
до тех пор, пока массив не будет отсортирован. Если во время прохода встретится пара элементов, которые
непосредственно идут друг за другом и имеют неверный порядок, то они меняются местами. Time Complexity --- $O(n^2)$,
Space Complexity --- $O(1)$.

\paragraph{Сортировка выбором.} В первом проходе выбирает наименьший элемент массива и меняет его местами с первым.
На следующем этапе проходит по массиву начиная со второго элемента и выбирает наименьший элемент из этой части массива,
после чего меняет его местами со вторым элементом массива. Затем проходит по массиву начиная с третьего элемента, находит
минимальный и меняет его с третьим и т.\,д. Этот шаг повторяется до тех пор, пока число шагов не совпадет с длиной исходного массива.
Time Complexity --- $O(n^2)$, Space Complexity --- $O(1)$.

\paragraph{Сортировка вставками.} 
В начальный момент отсортированная последовательность пуста. На каждом шаге алгоритма выбирается один из
элементов входных данных и помещается на нужную позицию в уже отсортированной последовательности до тех пор,
пока набор входных данных не будет исчерпан.
Time Complexity --- $O(n^2)$ в худшем случае и $O(n)$, если массив уже отсортирован. Space Complexity --- $O(1)$.

{\small
Алгоритм можно ускорить, если для поиска позиции элемента в отсортированной части массива
использовать бинарный поиск вместо линейного.

Сортировка вставками имеет довольно маленькую константу, блягодаря чему используется в функции \verb|std::sort|
для сортировки небольших массивов или маленьких частей больших массивов как часть следующего алгоритма. }

\paragraph{Быстрая сортировка.} Time Complexity --- $O(n\log n)$ в среднем, $O(n^2)$
в худшем (если входной массив уже отсортирован) случае. Space Complexity --- $O(1)$.
Быстрая сортировка функционирует по принципу <<разделяй и властвуй>>:
\begin{enumerate}
  \item Массив $a[l\dots r]$ ($l$ --- индекс самого первого, $r$ --- самого последнего элемента)
  разбивается на два подмассива $a[l\dots q]$ и $a[q+1\dots r]$, таких что каждый элемент $a[l\dots q]$
  меньше или равен $a[q]$, который в свою очередь, не превышает любой элемент подмассива $a[q+1\dots r]$.
  \textit{Индекс опорного элемента}$q$ вычисляется в ходе процедуры разбиения.
  \item Подмассивы $a[l\dots q]$ и $a[q+1\dots r]$ сортируются рекурсивно.
\end{enumerate}

Распространенной является функция разбиения Хоара, которая выбирает средний элемент массива
в качестве опорного. Однако так делать не обязательно. В качестве опорного можно выбирать
абсолютно любой элемент массива.

Если кому-либо известен алгоритм функции разбиения, то он может злонамеренно соорудить
такой массив, на котором функция быстрой сортировки уйдет в $O(n^2)$ и/или возникнет
переполнение стека. Чтобы избежать этого, в качестве опорного можно выбирать случайный
элемент массива.

Ниже приведен алгритм Quicksort с разбиением Хоара.
\begin{verbatim}
#include <iostream>
#include <utility>

/// a - массив, который сортируется
/// l - левая граница сортируемого отрезка
/// r - правая граница
int Partition(int *a, int l, int r) {
  int v = a[(l + r) / 2];
  int i = l;
  int j = r;
  while (i <= j) {
    while (a[i] < v) {
      ++i;
    }
    while (a[j] > v) {
      --j;
    }
    if (i >= j) {
      break;
    }
    std::swap(a[i++], a[j--]);
  }
  return j;
}

void Quicksort(int *a, int l, int r) {
  if (l < r) {
    int q = Partition(a, l, r);
    Quicksort(a, l, q);
    Quicksort(a, q + 1, r);
  }
}

int main() {
  int a[7] = {5, 10, -2, -3, 0, 1, 7};
  Quicksort(a, 0, 6);
  for (int i = 0; i < 7; ++i) {
    std::cout << a[i] << ' ';
  }
  std::cout << '\n';
}
\end{verbatim}

\paragraph{Сортировка слиянием.}
Разделяет исходный массив на два равных подмассива, после чего рекурсивно сортирует их по отдельности и объединяет.
Массивы разделяются до тех пор, пока в них не останется одного элемента.

Алгоритм сортировки таков:
\begin{enumerate}
  \item Если в массиве 1 элемент --- завершиться.
  \item Найти середину массива.
  \item Посортировать первую половину.
  \item Посортировать вторую половину.
  \item Объединить массив.
\end{enumerate}

Алгоритм объединения массивов:
\begin{enumerate}
  \item Циклично проходим по двум массивам.
  \item В объединяемый ставим тот элемент, что меньше.
  \item Двигаемся дальше, пока не дойдем до конца обоих массивов.
\end{enumerate}

Time Complexity: $O(n\log n)$, Space Complexity: $O(n)$.

{\small На степике также упоминается \textbf{сортировка Шелла} и \textbf{пирамидальная сортировка}
(она же Heapsort или сортировка кучей), но их суть кратко описать довольно затруднительно.}

\section{Функции языка С для работы со строками}
\textbf{Строки} используются для представления текстовой информации.
В языке C строки рассматриваются как массивы символов (\verb|char|), заканчивающиеся
специальным зарезервированным символом с кодом 0.

% Также существуют (но реже используются) <<широкие>> строки, которые являются аналогичными
% массивами символов \verb|wchar_t|.

Прототипы функций для работы со строками в языке C находятся в заголовочном файле \verb|<string.h>|
(в языке C++ для работы с C-строками --- \verb|<cstring>|).

\verb|size_t strlen(const char *s)| - определяет длину строки \verb|s| без учёта нуль-символа.

\subsection*{Копирование строк}

\verb|char *strcpy(char *dst, const char *src)| --- выполняет побайтное копирование символов из строки \verb|src|
в строку \verb|dst|. Возвращает указатель \verb|dst|. Программист должен удостовериться, что \verb|dst| указывает
на участко памяти достаточного размера.

strncpy(s1,s2, n) - выполняет побайтное копирование n символов из строки  s2 в строку s1. возвращает значения s1
Конкатенация строк

\verb|char* strcat(char *dst, const char *src)| - объединяет строку \verb|src| со строкой \verb|dst|.
Результат сохраняется в \verb|dst|. 

strncat(s1,s2,n) - объединяет n символов строки s2 со строкой s1. Результат сохраняется в s1
\subsection*{Сравнение строк}

strcmp(s1,s2) - сравнивает строку s1 со строкой s2 и возвращает результат типа int:
0 –если строки эквивалентны, >0 – если s1<s2,  <0  — если s1>s2 С учётом регистра

strncmp(s1,s2,n) - сравнивает n символов строки s1 со строкой s2 и возвращает результат типа int:
0 –если строки эквивалентны, >0 – если s1<s2,  <0  — если s1>s2 С учётом регистра

stricmp(s1,s2) - сравнивает строку s1 со строкой s2 и возвращает результат типа int:
0 –если строки эквивалентны, >0 – если s1<s2,  <0  — если s1>s2 Без учёта регистра

strnicmp(s1,s2,n) - сравнивает n символов строки s1 со строкой s2 и возвращает результат типа int:
0 –если строки эквивалентны, >0 – если s1<s2,  <0 — если s1>s2 Без учёта регистра
\subsection*{Обработка символов}

isalnum(c) - возвращает значение true, если с является буквой или цифрой, и false в других случаях

isalpha(c) - возвращает значение true, если с является буквой,  и false в других случаях

isdigit(c) - возвращает значение true, если с является цифрой, и false в других случаях

islower(c) - возвращает значение true, если с является буквой нижнего регистра, и false в других случаях

isupper(c) - возвращает значение true, если с является буквой верхнего регистра, и false в других случаях

isspace(c) - возвращает значение true, если с является пробелом, и false в других случаях

toupper(c) - если символ с, является символом нижнего регистра, то функция возвращает преобразованный символ
с в верхнем регистре, иначе символ возвращается без изменений.
\subsection*{Функции поиска}

strchr(s,c) -  поиск первого вхождения символа с в строке s. В случае удачного поиска возвращает указатель
на место первого вхождения символа с. Если символ не найден, то возвращается ноль.

strcspn(s1,s2) - определяет длину начального сегмента строки s1, содержащего те символы, которые не входят в строку s2

strspn(s1,s2) - возвращает длину начального сегмента строки s1, содержащего только те символы, которые входят в строку s2

strprbk(s1,s2) - Возвращает указатель  первого вхождения любого символа строки s2 в строке s1

\subsection*{Функции преобразования}

atof(s1) - преобразует строку s1 в тип double

atoi(s1) - преобразует строку s1 в тип int

atol(s1) - преобразует строку s1 в тип long int
Функции стандартной библиотеки ввода/вывода <stdio>

getchar(с) - считывает символ с со стандартного потока ввода, возвращает символ в формате int

gets(s) - считывает поток символов со стандартного устройства ввода в строку s до тех пор, пока не будет нажата клавиша ENTER

\vspace{1cm}

Функции для работы с Си-строками никогда не выделяют память, если оказывается, что размер буфера недостаточен. Это 
может привести к неопределенному поведению и ощибкам сегментации. О выделении
достаточного размера памяти должен заботиться программист, который вызывает функцию.

\section{Методы языка С++ для работы со строками}

\section{Декларация структур (struct) в С/С++. Отличия в декларации}
\textbf{Структура} \label{def:struct} --- производный тип данных, который представляет какую-то определенную сущность.
Для определения структуры используется ключевое слово \verb|struct|:

\begin{verbatim}
struct ИмяСтруктуры {
  поля_структуры;
};
\end{verbatim}
Поля структуры --- это объявленные внутри структуры переменные, доступ к которым можно получать через объект структуры
с помощью оператора \verb|.| или через указатель на объект структуры через оператор \verb|->|.

В языке C, в отличие от C++, объявленная таким образом структура будет доступна под именем
\verb|struct ИмяСтруктуры| (в C++ --- просто \verb|ИмяСтруктуры|). Чтобы не писать слово
\verb|struct|, можно объявить псевдоним для типа структуры с помощью ключевого слова
\verb|typedef|. В C++ так тоже можно делать для обратной совместимости с Си. В C++
для полей структур можно задавать значения по умолчанию.

{\small В языке C++ во всех структурах неявно объявляется конструктор и деструктор по умолчанию
(если они не объявлены явно). Коснтруктор вызывается при объявлении (и/или инициализации) объекта
структуры (также при вызове оператора \verb|new|), а деструктор --- когда объект покидает
область видимости или вызывается оператор \verb|delete|.}

\begin{verbatim}
#include <iostream>
#include <cstdint>

struct Vector2 {
  float x;
  // Значение по умолчанию
  float y = 0;
};

typedef struct Vector2 vector2_t;

// typedef можно писать и сразу. Название структуры можно опускать
typedef struct {
  size_t size;
  char* str;
} string_t;

typedef struct Segment {
  Vector2 a;
  Vector2 b;
} segment_t;

int main() {
  // Обращение в стиле Си
  struct Vector2 a = {1.0, -3.0};
  vector2_t b = {1.0, 3.4};
  // Обращение в стиле C++
  Vector2 c = {-2.0, -0.4};

  // Анонимная структура. У нее нет названия,
  // но в остальном она работает как обычная структура.
  struct {
    double x;
    double y;
  } point = {.x = a.x, .y = a.y};
  // В строчке выше используется designated intializer,
  // который позволяет указывать названия полей, которые
  // инициализируются. (перед названием поля для этого)
  // ставится точка.
  // В Си это было с незапамятных времен, а в C++
  // стандартизировано лишь в C++20

  // Обращение к полю x
  std::cout << b.x + a.x + c.x << '\n';
  
  // Ипользование псевдонима и динамического выделения памяти
  segment_t *segment = new segment_t;
  // Обращение через указатель на структуру
  segment->a = a;
  segment->b = c;
  delete segment;
  return 0;
}
\end{verbatim}

\section{Инициализация и доступ к элементам структуры. Выравнивание}
Определение понятия структуры см. \hyperref[def:struct]{выше}.

Элементами структуры являются поля и методы структуры.
Доступ к элементам структуры можно получать через объект структуры
с помощью оператора \verb|.| или через указатель на объект структуры через оператор \verb|->|.
Пример в предыдущем вопросе.

\subsection*{Инициализация}

Инициализация струтруры в языках C и C++ частично отличается. Так, в языке C++
присутствует конструктор по умолчанию --- метод структуры, который неявно
вызывается компилятором при создании объекта структуры. Он же вызывается (но
уже фактически явно) и при выделении памяти с помощью оператора \verb|new|.
В языке C ничего подобного нет.

Конструктор по умолчанию в языке C++ инициализирует все поля значениями по
умолчанию, которые можно указывать явно. Если значения явно не указано, то
поля простых типов наподобие \verb|int| или указатели инициализируются нулями,
если структура располагается в статической памяти или в куче\footnote{при
выделении памяти с помощью оператора new. Особо искушенные последователи Культа
также знают о placement new, который может проинициализировать любой участок памяти (в
т.\,ч. выделенный с помощью malloc.)}
; и мусором, если
структура объявлена на стеке.
\begin{verbatim}
typedef struct {
  int a = 42;
  int c;
} ExampleStruct;

static ExampleStruct e1;

int main() {
  ExampleStruct e2;
  // 42 42
  std::cout << e1.a << ' ' << e2.a << '\n';
  // 0 <мусор>
  std::cout << e1.c << ' ' << e2.c << '\n';
}
\end{verbatim}

Для инициализации полей структур в Си используется перечисление значений
в порядке объявления полей. Также допустима инициализация с явным указанием
пар поле-значение:
\begin{verbatim}
typedef struct Example {
  int a;
  float f;
};

// Обычная инициализация
Example e1 = {0, 0.4};
// designated initializer
Example e2 = {.a = 0, .f = 0.4};
\end{verbatim}

Оба этих вида инициализации также поддерживаются языком C++ (вторая --- начиная с C++20).
Кроме того, начиная с C++11 поддерживается еще один вид инициализации:
\begin{verbatim}
Example e3{0, 3.14};
\end{verbatim}

\subsection*{Выравнивание}

Обычно процессоры эффективнее загружают и выгружают данные, когда они \textbf{выравнены},
то есть их адрес кратен какой-либо степени числа 2. Это число называется \textbf{выравниванием}
и зависит от типа данных.

Все простые типы (кроме \verb|long| \verb|double|,
он выравнен по 16 байтам) должны быть выравнены по своему размеру,
то есть их адрес в памяти должен быть кратен размеру этого типа.
Так, адрес 4-байтного \verb|int| должен быть кратен числу 4, а адрес переменной
однобайтного типа \verb|char| может быть любым.
Выравнивание всей структуры равно выравниванию ее первого поля.

В заголовочном файле \verb|<cstddef>| определен макрос\\ \verb|offsetof(type, member)|,
значение которого равно отступу поля (расстоянию в байтах от начала структуры до начала
самого поля) \verb|member| структуры \verb|type|.

Узнать выравнивание типа (начиная с C++11) можно с помощью
оператора \verb|alignof|, аналогичного оператору \verb|sizeof|.

С целью выравнивания при создании структур компилятор может добавлять
неиспользуемые байты --- \textbf{паддинги} между двумя полями,
если у предыдущего выравнивание меньше, чем следующего. Также паддинги
могут добавляться и в конце структуры, вероятно, чтобы обеспечить корректное
выравнивание для последующих структур в массиве.

Основными компиляторами (MSVC, GCC, Clang) поддерживается нестандартная директива
\verb|#pragma pack(|$N$\verb|)|, которая позволяет ограничить максимальное
выравнивание полей структуры $N$ байтами (<<упаковать>> структуру), где $N \in \{1,2,4,8,16\}$.
В частности, \verb|#pragma pack(1)| полностью отключает выравнивание.

Использование директивы \verb|#pragma pack|
применяет упаковку ко \textit{всем} структурам, которые объявлены после нее\footnote{по крайней мере, в GCC и Clang}.
Это относится и к тем структурам, которые могут быть объявлены в других заголовочных файлах.
Если при компиляции данного файла компилятор будет думать, что структура упакована,
но другой код, с которым линкуется этот файл, компилировался без учета упаковки,
то бинарное представление структур в памяти (ABI) окажется несовместимым и
программа, вероятно, упадет.

Чтобы избежать этого, упаковки структур следует оборачивать в директивы
\verb|pack(push)| и \verb|pack(pop)|, как в примере ниже.

\begin{verbatim}
#include <cstddef>
#include <iostream>
  
struct S {
  char   m0; // 1 байт
  // <паддинг 7 байт> 
  double m1;
  short  m2;
  char   m3;
  // <паддинг 5 байт>
};

#pragma pack(push)
#pragma pack(1)
struct SPacked {
  char   m0;
  double m1;
  short  m2;
  char   m3;
};
#pragma pack(pop)
  
int main() {
  std::cout
    // 24
    << "S:          " << sizeof(S) << '\n'
    // 0
    << "char   m0 = " << offsetof(S, m0) << '\n'
    // 8
    << "double m1 = " << offsetof(S, m1) << '\n'
    // 16
    << "short  m2 = " << offsetof(S, m2) << '\n'
    // 18
    << "char   m3 = " << offsetof(S, m3) << "\n\n";

  // 8 4
  std::cout
    << alignof(double) << ' '
    << alignof(int) << "\n\n";

  std::cout
    // 12
    << "SPacked:    " << sizeof(SPacked) << '\n'
    // 0
    << "char   m0 = " << offsetof(SPacked, m0) << '\n'
    // 1
    << "double m1 = " << offsetof(SPacked, m1) << '\n'
    // 9
    << "short  m2 = " << offsetof(SPacked, m2) << '\n'
    // 11
    << "char   m3 = " << offsetof(SPacked, m3) << '\n';
}
\end{verbatim}

\section{Вложенные структуры и массивы структур}
Полем структуры может являться любой полный тип и, в частности, другая структура.

Структура не является полным типом до конца ее объявления, поэтому она не может
содержать саму себя в качестве поля, поскольку это привело бы к тому, что такая
структура должна иметь бесконечный размер. Однако структура может содержать
указатель или ссылку на себя.

\begin{verbatim}
struct Node {
  int value;
  // Ошибка компиляции: Field has incomplete type
  Node next;
};

// Валидно
struct RefNode {
  int value;
  Node &next;
};

struct PtrNode {
  int value;
  Node *prev = nullptr;
  Node *next = nullptr
};

// Двусвязный список
struct List {
  PtrNode head;
  PtrNode tail;
};
\end{verbatim}

Выравнивание структуры в принципе и вложенной структуры в частности равно самому
большому выравниванию среди ее (вложенной структуры) полей.
\begin{verbatim}
struct A {
  int x;
  char c;
  double y;
};

struct B {
  char c;
  A a;
};

std::cout
  // 16 8
  << sizeof(A) << ' ' << alignof(A) << '\n'
  // 24 8
  << sizeof(B) << ' ' << alignof(B) << '\n'
  // 8
  << offsetof(B, a) << '\n';

\end{verbatim}

Массив структур объявляется точно так же, как и массив простых типов.
Для создания и освобождения динамических массивов лучше использовать
операторы \verb|new []| и \verb|delete[]|, поскольку они вызывают
конструкторы и деструкторы и позволяют корректно инициализировать и
освобождать память полей, которые имеют производные типы(например,
\verb|std::string|).
\begin{verbatim}
struct Vector2 {
  int x;
  int y;
};

Vector2 static_array[100];

Vector2 dyn_array = new Vector2[100];
delete[] dyn_array;
\end{verbatim}

\section{Указатели на структуры}
Совершенно бессмысленный вопрос. Тут даже не о чем говорить.

Вся общая теория указателей (\hyperref[sec:ptr_arithm]{арифметика указателей}, разыменования) также
применима к указателям на структуры. Для доступа к элементам структуры можно использовать
оператор стрелочка (\verb|->|): (\verb|ptr->field|); или садомазохистскую запись с разыменованием структуры
и доступом к полю через объект структуры с помощью оператора точка (\verb|.|): \verb|(*ptr).field|.

\begin{verbatim}
struct Person {
  int age;
  std::string name;
};

Person *jack = new Person {27, "Jack"};

Person *peter = new Person;
peter->name = "Peter";
(*peter).age = 17;

// Jack is 27
std::cout << jack->name << "is " << jack->age << '\n';
// Peter is 17
std::cout << peter->name << "is " << peter->age << '\n';

delete peter;
delete jack;
\end{verbatim}

\section{Объединения и битовые поля}
\subsection*{Объединения}
\textbf{Объединение} --- группирование переменных, которые разделяют одну и ту же область памяти.

Объявление объединения (типа объединения или шаблона объединения) начинается с ключевого слова union.

\begin{verbatim}
union ИмяТипаОбъединения {
  Тип1 переменная_1;
  Тип2 переменная_2;
  ...
  ТипN переменная_n;
};
\end{verbatim}

Где
\textbf{ИмяТипаОбъединения} --- непосредственно имя новосозданного объединения;

\textbf{переменная\_1, \dots, переменная\_n} --- имена переменных, которые являются полями объединения.
Эти переменные могут быть разных типов;

\textbf{Тип1, \dots, ТипN} --- типы полей объединения.

\paragraph{Размер объединения} равен размеру самого большого поля.

Объединение относится к определенному участку памяти, в котором может находиться объект одного из типов,
которые есть в объединении. При попытке перезаписать данные другим типом новые данные записываются
поверх старых, а для старых данных деструктор не вызывается. Поэтому в \verb|union| без
дополнительных плясок с бубном нельзя поместить <<умный>> производный тип наподобие \verb|std::string|.

При обращении к полю объединения записанные в память данные будут
интерпретироваться как данные того типа, к которому относится переменная, к которой происходит
обращение. Нетрудно догадаться, что обращение к неправильному типу может вызвать UB.

\begin{verbatim}
// Можно объявлять и анонимные union.
// Тогда их поля попадут в ту же область
// видимости, где и объявлено объединение.
union {
  float f;
  int i;
} united;
// Одно из возможных побитовых представлений NaN по IEE754.
united.i = 0x7f800001;
// nan
std::cout << united.f << '\n';
\end{verbatim}

Резюмируя:
\begin{enumerate}
  \item Объединения можно использовать для хранения одного из заданных типов данных. Чтобы знать,
  какой именно тип хранится в объединении, надо хранить эту информацию отдельно.
  \item Объединения можно использовать для побитового преобразования одного типа в другой
\end{enumerate}

{\small В C++ для более безопасного хранения нескольких типов в одном участке памяти можно использовать
\verb|std::variant|, а для побитовго преобразования (начиная с C++20) --- \verb|std::bit_cast|.}

\subsection*{Битовые поля}
\textbf{Битовое поля} позволяют задать длину поля структуры в битах. % получать доступ к конкретным битам структур.
То есть, они как бы позволяют получать целочисленные типы произвольной (но не
более машинного слова) длины. Битовые поля объявляются точно так же, как и обычные,
но после имени поля через двоеточие указывается его длина.
\begin{verbatim}
struct ИмяСтруктуры {
  <bool | unsigned <char|int|short|long|long long>> имя_поля: длина;
};
\end{verbatim}

Обратите внимение, что только битовые поля могут иметь только целочисленные типы.
{\small Желательно, чтобы они были \verb|unsigned|. Хотя использование обычных (знаковых)
чисел не запрщается, оно, вообще говоря, может привести к неожиданным результатам (отрицательные числа) и даже к UB\textsuperscript{проверить?},
потому что способ представления отрицательных чисел до C++20 не был стандартизирован.
С C++20 все компиляторы обязаны использовать дополнительный код.}

Максимальное число, которое может поместиться в битовое поле длины $n$, равно $2^n - 1$.
Обычно, если несколько битовых полей (неважно каких типов) объявлены друг за другом, то
компилятор их ужимает так, чтобы они имели наименьший размер. При этом неиспользуемые в
битовых полях биты становятся недоступными и превращаются в паддинг (a.k.a. `struct offset').

В приведенном ниже примере (нумерация с нуля) биты 5, 6, 7 игнорируются и программа
выведет 31 ($31 = 2^5 - 1$) и 255. Битовое поле \verb|c| позволяет получить доступ к первым пяти битам числа:
\begin{verbatim}
union {
  struct {
    unsigned char c: 5;
  } bitfield;
  unsigned char num;
};

// Все биты заполенены единицами
num = 255;
std::cout << (unsigned int) bitfield.c
          << ' ' << (unsigned int) num << '\n';

// =========================================================
// Битовые поля позволяют компактно хранить булевых значений
struct BitSet {
  bool b1 : 1;
  bool b2 : 1;
  bool b3 : 1;
  bool b4 : 1;
  bool b5 : 1;
  bool b6 : 1;
  bool b7 : 1;
  bool b8 : 1;
};

BitSet Compress(bool b[8]) {
  BitSet res;
  res.b1 = b[0];
  res.b2 = b[1];
  res.b3 = b[2];
  res.b4 = b[3];
  res.b5 = b[4];
  res.b6 = b[5];
  res.b7 = b[6];
  res.b8 = b[7];
  return res;
}
  
int main() {
  bool bool_array[8] = {true, true, true, false,
                        false, true, false, true};
  BitSet bitset = Compress(bool_array);
  std::cout
    << bool_array[0] << ' ' << bitset.b1 << '\n'  // 1 1
    << bool_array[1] << ' ' << bitset.b2 << '\n'  // 1 1
    << bool_array[2] << ' ' << bitset.b3 << '\n'  // 1 1
    << bool_array[3] << ' ' << bitset.b4 << '\n'  // 0 0
    << bool_array[4] << ' ' << bitset.b5 << '\n'  // 0 0
    << bool_array[5] << ' ' << bitset.b6 << '\n'  // 1 1
    << bool_array[6] << ' ' << bitset.b7 << '\n'  // 0 0
    << bool_array[7] << ' ' << bitset.b8 << '\n'; // 1 1
}
\end{verbatim}

\section*{Время хранения (storage duration). Связывание}
Эта информация в равной мере относится к последующим трем вопросам. Поэтому я решил ее
вынести в отдельный раздел.

\textbf{Время хранения} --- это свойство объекта, которое определяет минимальное
возможное время жизни хранилища, содержащего объект\footnote{\url{https://en.cppreference.com/w/cpp/language/storage_duration}}.
Время хранения зависит от способа объявления объекта и может быть одним из следующих:

\begin{itemize}
  \itembf{Статическое}. Все глобальные переменные и переменные, впервые объявленные с использованием
  спецификатора \verb|static| или \verb|extern|, которые не имеют потоковое время хранения.
  Хранилище живет на протяжении всего исполнения программы.
  \itembf{Потоковое} {\small\textit{(С C++11)}}. Все перменные, объявленные \verb|thread_local|.
  Хранилище живет на протяжении жизни потока, в котором переменная создана. У каждого потока имеется
  своя уникальная копия объекта.
  \itembf{Автоматическое}. Смотреть \hyperref[def:auto_storage]{ниже}.
  \itembf{Динамическое}. Все объекты, созданные во время исполнения программы:
  объекты, созданные с помощью оператора \verb|new| или динамически выделенные на куче,
  а также исключения (``allocated and deallocated in an unspecified way'').
\end{itemize}

Будем говорить, что переменная (символ) имеет \textbf{внутреннее} связывание, если он доступен
только из той единицы трансляции, в которой объявлен.

Будем говорить, что переменная (символ) имеет \textbf{внешнее} связывание, если доступ к нему
можно получить из любой единицы трансляции.

Стандарт также выделяет переменные \textbf{без связывания} --- все переменные внутри функций (блоков),
которые явно не объявлены \verb|static| или \verb|extern|.

\section{Локальные и глобальные переменные}
\paragraph{Локальные переменные} объявляются внутри тела функции или блока и доступны только изнутри
функции или блока, в котором объвлены. Локальные переменные могут иметь \textit{любое} время хранения.

\begin{verbatim}
// Два файла компилировать вместе
// В файле lib.cc
int a = 42;

// В файле main.cc
#include <iostream>

void Func() {
  // статическое время хранения (внешнее связывание)
  // сейчас эта переменная локальная
  // но если эту же декларацию вынести за пределы
  // функции, то эта переменная станет глобальной
  extern int a;
  std::cout << "a = " << a << '\n';
}

void Counter() {
  // статическое время хранения (внутреннее связывание)
  // чисто локальная переменная
  static int count = 0;
  std::cout << "count = " << ++count << '\n';
}

void PrintHi() {
  // автоматическое время хранения
  std::string name;
  std::cin >> name;
  std::cout << "Hello, " << name << "!\n";
}

int main() {
  // 42
  Func();
  // 42
  Func();

  // Ошибка компиляции
  // a = 24;

  // 1
  Counter();
  // 2
  Counter();

  // Ошибка компиляции
  // std::cin >> count;
  PrintHi();

  // Ошибка компиляции
  // name = "Doomguy";

  //3
  Counter();

  {
    int x = -3;
    std::cout << x << '\n';
  }
  // Ошибка компиляции
  // x = 3;
}
\end{verbatim}

\paragraph{Глобальные переменные} объявляются вне тела функции и доступны из любых функций.
Глобальные пременные имеют статическое или потоковое время хранения и могут иметь как внешнее,
так и внутренне связывание. Все глобальные переменные хранятся в статической области памяти.

Поскольку глобальные переменные доступны из любой функции, их значение может поменять кто угодно.
Это может нарушить внутренние взаимосвязи в программе, из-за чего их использование (особенно с
внешним связыванием) не рекомендуется.

\begin{verbatim}
// Глобальная переменная
std::string name;

void ReadName() {
  std::cout << "Введите ваше имя: ";
  std::cin >> name;
}

void Welcome() {
  std::cout << "Добро пожаловать, " << name << "!\n";
}

int main() {
  ReadName();
  Welcome();
}
\end{verbatim}

\section{Автоматические переменные}
Переменная имеет \textbf{автоматическое} время хранения, если выполнено одно из двух условий:
\label{def:auto_storage}
\begin{enumerate}
  \item Переменная принадлежит области видимости блока (\verb|{}|) и явно не объявлена \verb|static|, \verb|extern| или \verb|thread_local|
  (см. \hyperref[sec:ext_stat]{следующий вопрос}).
  Хранение этих переменных длится до тех пора, пока существует блок, в котором они объявлены.
  \item Переменная является параметром функции. Хранение параметров функции длится до их уничтожения при выходе из функции.
\end{enumerate}
Других автоматических переменных нет.

Автоматические переменные обычно хранятся на стеке, однако компиляторы с целью
оптимизации могут помещать их в регистры процессора.

До C++11 можно было явно указать автоматическое время хранения с помощью
ключевого слова \verb|auto|. Начиная со стандарта C++11 ключевое слово
\verb|auto| приобрело новое значение: теперь оно позволяет явно не указывать
тип переменной. В таком случае тип переменной выводится статически во время
компиляции и не может быть изменен во время исполнения.

\begin{verbatim}
std::string ReadName() {
  // автоматическая переменная
  std::string name;
  std::cout << "Введите ваше имя: ";
  std::cin >> name;
  return name;
}

void Welcome(/* автоматическая переменная */
             std::string name1)
{
  std::cout << "Добро пожаловать, " << name1 << "!\n";
} // <- Здесь переменная name1 уничтожена

int main() {
  // автоматичекая локальная переменная
  std::string name = ReadName();
  Welcome(name);
} // <- Здесь переменная name уничтожена
\end{verbatim}

\section{Внешние и статические переменные, особенности их реализации}
\label{sec:ext_stat}
Термин `статическая переменная' неоднозначен: он может обозначать как переменную,
которая находится в статической области памяти (любая не-\verb|thread_local| глобальная
переменная или локальная переменная с внутренним или внешним связыванием),
так и переменную с внутренним связыванием (глобальная или локальная переменная, объявленная
\verb|static|). \textbf{Статической переменной} будем называть переменную, которая располагается
в статической облати памяти.

Переменные как с внешним, так и с внутренним связыванием хранятся в статической области
памяти, то есть являются статическими в смысле данного выше определения.

В отличие от кучи и стека, размер статической памяти постоянен и не может меняться во время
исполнения.

Переменные с внутренним связыванием могут быть как глобальными, так и локальными.
Про глобальные переменные разговор будет ниже, а пока остановимся на локальных.
Однако локальные переменные с внутренним связыванием хранятся не на стеке, а в статической
памяти, потому они не очищаются при выходе из функции. Это позволяет сохранять состояние
между вызовами функции. Статические локальные переменные инициализируются только один раз:
тогда, когда строка с такой переменной впервые выполняется. Когда статическая локальная переменная
при выполнении программы встречаеся в следующий раз, она не инициализируется повторно.

\begin{verbatim}
#include <iostream>

void f(int val0) {
  static int saved = val0;
  std::cout << saved << ' ';
  ++saved;
}
int main() {
  // 4
  f(4);
  // 5
  f(0);
  // 6
  f(-3);
  std::cout << '\n';
}
\end{verbatim}

\textbf{Внешняя} переменная --- это переменная, которая имеет внешнее связывание,
то есть доступна из других единиц трансляции. Такими переменными
являются глобальные переменные, определенные (defined) без спецификатора \verb|static| или с
спецификатором \verb|extern|.

Хотя нормальные компиляторы (GCC, Clang, MSVC?) поддерживают определение переменной с ключевым словом
\verb|extern| (см. переменную \verb|c| ниже), оно предназначено только для объявления переменной. Если определить
значение этой переменной в нескольких единицах трансляции, то возникнет ошибка компоновки.

\begin{verbatim}
// obj.cc
// Внешние переменные, доступные из любых единиц трансляции
int a = 1;
int b = 2;
// Предупреждение GCC и Clang
extern int c = 3;
// Переменная с внутренним связыванием
static float pi = 3.1416;

float GetPi() {
  return pi;
}

// main.cc
#include <iostream>

extern int a;
extern int b;


// Использование этих переменных приведет к ошибке компоновки
extern int d;
extern float pi;

extern float GetPi();

void Swap() {
  int buf = a;
  a = b;
  b = buf;
}

int main() {
  // Да, так тоже можно. Переменная `c` (если не объявлена
  // в другом месте) будет доступна в теле функции `main`.
  // Но в этой строке попытаться присвоить
  // переменной значение, программа не скомпилируется
  extern int c;
  
  // 1 2
  std::cout << a << ' ' << b << '\n';
  a += 23;
  // 24
  std::cout << a << '\n';
  Swap();
  // 2 24
  std::cout << a << ' ' << b << '\n';

  // 3.1416 3
  std::cout << GetPi() << ' ' << c << '\n';

  // Ошибка компоновки
  // std::cout << ' ' << pi << ' ' << d << '\n';
}

\end{verbatim}


\section{Символические константы: \#define. Включение файла: \#include}
\paragraph{\#include} подставляет вместо себя содержимое указанного файла. Синтаксис:
\begin{verbatim}
  #include <файл>
\end{verbatim}
или
\begin{verbatim}
  #include "файл"
\end{verbatim}
Подключаемый файл может находиться либо в той же директории, в которой лежит и исходный файл,
либо в одном из системных путей (на Linux обычно \verb|/usr/include/| и \verb|/usr/include/c++/<версия GCC>/|).

При использовании синтаксиса с кавычками препроцессор сначала ищет файлы в той же директории,
где находится сам файл, и только потом --- в системных путях; а при использовании треугольных скобок --- наоборот.

{\small Можно добавить системные пути с помощью флага \verb|-I| (GCC, Clang) или \verb|/I| (MSVC) компилятора. }

Хотя директива \verb|#include| может использоваться для подключения произвольных файлов в произвольное место
любого файла, делать это не рекомендуется. Директиву надо применять для подключения заголовочных файлов, содержащих
объявления функций, структур, классов и т.\,д. Например, в заголовочном файле \verb|cmath|
стандартной библиотеки содержатся объявления математических функций \verb|std::sqrt|, \verb|std::sin|,
\verb|std::round| и других. В файле \verb|iostream| содержатся функции и структуры для ввода-вывода информации
в консоль.

Руководство Google по стилю кода рекомендует использовать \verb|<>| для подключения системных заголовков
и стандартной библиотеки; и \verb|""| для подключения всех остальных заголовков (за редкими исключениями, напр. \verb|<Python.h>|).

\paragraph{\#define} позволяет определять символьные константы\footnote{для краткости я буду их называть макросами,
но гипотетически Вадим может к этому придраться}, вместо которых на этапе препроцессинга
будет подставляться указанное выражение.
Синтаксис таков:
\begin{verbatim}
  #define идентификатор выражение
  #define идентификатор(параметры, через, запятую) выражение
\end{verbatim}
где \verb|идентификатор| --- это имя макроса (любой валидный идентификатор),
а \verb|выражение| --- то, что будет подставляться вместо \verb|идентификатор|а.

В первом случае директива создает символическую константу (object-like macro),
вместо которой просто в лоб подставляется выражение.

Во втором случае директива создает функциональный макрос (function-like macro),
в которые можно передать несколько аргументов. Они будут подставлены в выражение
вместо параметров (см. пример). Поскольку в качестве аргумента макроса может
выступать любое выражение, которое подставляется в макрос прямым текстом, <<как есть>>,
параметры при использовании следует оборачивать в скобки, чтобы избежать неожиданных результатов
(ср. \verb|MUL| и \verb|CORRECT_MUL| в примере).

В выражении функционального макроса можно использовать два специальных оператора:
\verb|#параметр|, который оборачивает значение \verb|параметра| в кавычки,
превращая его в строковый литерал и \verb|##|, который позволяет сконкатенировать
параметр с чем угодно.

В \verb|выражении| можно использовать другие макросы (и они будут корректно разворачиваться),
а в процедурные макросы можно передавать другие макросы(в том числе и процедурные).

Отметим, что \verb|выражение| может быть пустым (в таком случае
вместо макроса подставится ничто). Также любой макрос можно впоследствии переопределить
с помощью директивы \verb|#define| либо разопределить с помощью директивы \verb|#undef|.
В коде после разопределения макроса компилятор будет вести себя так, как будто этого
макроса никогда и не было; но в коде между \verb|#define| и \verb|#undef| этот макрос
будет доступен.

{\small В C++11 появилась возможность создавать макросы с переменным числом параметров.
Это ужасно страшное колдунство. Подробнее смотри по ссылке:
\url{https://en.cppreference.com/w/cpp/preprocessor/replace}}

Пример:
\begin{verbatim}
#define QUESTION 52
#define ANSWER 42
#define SUM QUESTION + ANSWER
#define MERGE(x) v##x
#define MKSTRING(x) #x

#define MUL(x, y) x*y
#define CORRECT_MUL(x, y) (x) * (y)

int v42 = 24;
int vANSWER = -24;

// 10 94
std::cout << QUESTION - ANSWER << ' ' << SUM << '\n';
// 24 0
std::cout << MERGE(42) << ' ' << MERGE(42) + MERGE(ANSWER) << '\n';
// Hello OAiP
std::cout << MKSTRING(Hello OAiP) << '\n';
// 5 9
std::cout << MUL(3, 1 + 2) << ' ' << CORRECT_MUL(3, 1 + 2) << '\n';

#undef ANSWER
// Ошибка компиляции
std::cout << ANSWER << '\n';
\end{verbatim}


\section{Директивы препроцессора: \#if, \#ifdef, \#ifndef, \#else, \#endif}
Эти директивы препроцессора предназначены для условной компиляции, то есть они позволяют
включить или выключить компиляцию определенных участков кода. Директивы создают ветвления
на этапе препроцессора.

\paragraph{\#if} имеет следующий синтаксис:
\begin{verbatim}
#if <условие>
// скомпилировать код
#endif
\end{verbatim}
Подобно оператору(?) ветвления в C++, включает компиляцию нижеследующего
участка кода, если выполнено заданное условие. В условии можно использовать:
\begin{itemize}
  \item Числовые и символьные константы (\verb|42, 'Y'|)
  \item Арифметические, побитовые и логические операции
  \item Макросы
  \item Оператор \verb|defined(<макрос>)|. Если \verb|<макрос>| был ранее по тексту программы определен с помощью директивы препроцессора
  \verb|#define|, то оператор возвращает 1, иначе -- 0
  \item Идентификаторы, которые не являются ранее определенными макросами. Вместо них подставляется число 0.
\end{itemize}
Если при вычислении записанного в условии выражения получится 0, то оно считается ложным; если же выйдет любое ненулевое число --- истинным.

Следует отметить, что в директивах нельзя использовать оператор \verb|sizeof|, поскольку препроцессор ничегно не знает о типах.

Также существует директива препроцессора \verb|#elif|, которая является полным аналогом конструкции \verb|else if|.

\paragraph{\#ifdef, \#ifndef} имеют одинаковый синтаксис:
\begin{verbatim}
#ifdef <макрос>
// скомпилировать код
#endif

#ifndef <макрос>
// скомпилировать код
#endif
\end{verbatim}

Директива \verb|#ifdef| включает компиляцию участка кода, если \verb|<макрос>| был ранее определен с помощью директивы \verb|#defined|.

Директива \verb|#ifndef|, наоборот, включает компиляцию участка кода, если \verb|<макрос>| \textbf{не} был ранее определен
с помощью директивы \verb|#defined|.

{\small \textit{Примечание. Макросы можно разопределить с помощью директивы} \verb|#undef| }

\paragraph{\#else} может использоваться только в связке с вышеназванными директивами:
\begin{verbatim}
#ifndef <условие>
  // скомпилировать, если <условие> выполнено
#else
  // скомпилировать, если <условие> не выполнено
#endif
\end{verbatim}

Если оказывается, что условие директив \verb|#if, #ifdef, #ifndef| ложно, то все то, что находится между директивами \verb|#if|
и \verb|#else| игнорируется, а компилируется то, что находится между \verb|#else| и \verb|#endif|.

\paragraph{\#endif} обозначает конец ветвления.

Эти директивы можно использовать для определения операционной системы (проверка макросов \verb|__linux__|, \verb|__ANDROID__|,
\verb|_WIN32|, \verb|macintosh|),
различения C и C++ (макрос \verb|__cplusplus|).

Также Руководство по стилю кода Google рекомендует использовать эти директивы для предотвращения повторного включения одного
и того же файла (include guards):
\begin{verbatim}
#ifdef MY_FANCY_HEADER_H_
#define MY_FANCY_HEADER_H_ 1

int Sum(int a, int b);
int Odd(int a, int b);
typedef int(*FunctionPtr)(int, int);

#endif // MY_FANCY_HEADER_H_
\end{verbatim}

Более сложный и бесполезный пример:
\begin{verbatim}
#ifndef __cplusplus
#include <stdio.h>
void SayHi() {
  printf("Thou usest C!\n");
}
#elif __cplusplus >= 202300L
#include <print>
void SayHi() {
  std::print("Your C++ version is {}, supergood!\n",
             __cplusplus);
}
#else
#include <iostream>
void SayHi() {
  std::cout << "Your C++ version is "
            << __cplusplus << ", kinda old :(\n";
}
#endif

int main() {
  SayHi();
  return 0;
}
\end{verbatim}

\url{https://gcc.gnu.org/onlinedocs/cpp/If.html}

\url{https://sourceforge.net/p/predef/wiki/OperatingSystems/}

\section{Понятие алгоритма. Введение в алгоритмизацию}
\textbf{Алгоритм} --- точное предписание, определяющее вычислительный процесс, ведущий от варьируемых
начальных данных к искомому результату.

\textbf{Алгоритмизация} --- процесс построения алгоритма решения задачи, результатом которого является
выделение этапов процесса обработки данных, формальная запись содержания этих этапов и определение
порядка их выполнения.

\subsection*{Свойства алгноритмов}
\begin{enumerate}
  \itembf{Дискретность.} Процесс решения задачи должен быть разбит на последовательность отдельных шагов — простых действий,
  которые выполняются одно за другим в определенном порядке. Каждый шаг называется командой (инструкцией).
  Только после завершения одной команды можно перейти к выполнению следующей.
  \itembf{Детерминированность} (определенность). Каждая команда алгоритма в отдельности и последовательность команд в
  целом должна быть точно и однозначно определена. Результат выполнения команды не должен зависеть ни от какой дополнительной
  информации. У исполнителя не должно быть возможности принять самостоятельное решение (т. е. он исполняет алгоритм формально,
  не вникая в его смысл).
  Благодаря этому любой исполнитель, имеющий необходимую систему команд, получит один и тот же результат на основании одних и
  тех же исходных данных, выполняя одну и ту же цепочку команд.
  \itembf{Конечность и результативность.} Исполнение алгоритма должно завершиться за конечное число шагов;
  при этом должен быть получен результат.
  \itembf{Массовость.} Алгоритм предназначен для решения не одной конкретной задачи, а целого класса задач, который определяется
  диапазоном возможных входных данных.
  \itembf{Понятность.} Каждая команда алгоритма должна быть понятна исполнителю. Алгоритм должен содержать только те команды,
  которые входят в систему команд его исполнителя.
\end{enumerate}

\subsection*{Способы описания алгоритмов}
\begin{enumerate}
  \item словесный;
  \item формульно-словесный;
  \item блок-схемный;
  \item псевдокод;
  \item структурные диаграммы;
  \item языки программирования.
\end{enumerate}
\paragraph{Пример словесного способа.} \textit{(деление обыкновенных дробей)} \\
В качестве входных данных даны две обыкновенные дроби. Для того чтобы разделить первую
дробь на вторую, необходимо:
\begin{enumerate}
  \item Числитель первой дроби умножить на знаменатель второй дроби.
  \item Знаменатель первой дроби умножить на числитель второй дроби.
  \item Записать дробь, числителем которой являет результат выполнения шага 1,
  знаменателем — результат выполнения шага 2.
\end{enumerate}
Описанный алгоритм применим к любым двум обыкновенным дробям. В результате его выполнения
будут получены выходные данные — результат деления двух дробей (входных данных).

\subsection*{Алгоитмические языки}
\textbf{Алгоритмический язык} --- это искусственный язык (система обозначений), предназначенный для записи алгоритмов.
Он позволяет представить алгоритм в виде текста, составленного по определенным правилам с использованием специальных служебных слов.
Количество таких слов ограничено. Каждое служебное слово имеет точно определенный смысл, назначение и способ применения.
При записи алгоритма служебные слова выделяют полужирным шрифтом или подчеркиванием.

В алгоритмическом языке используются формальные конструкции, но нет строгих синтаксических правил для записи команд.
Различные алгоритмические языки различаются набором служебных слов и формой записи основных конструкций.

Алгоритмический язык, конструкции которого однозначно преобразуются в команды для компьютера, называется \textbf{языком программирования}.
Текст алгоритма, записанный на языке программирования, называется \textbf{программой}.

\end{document}