## Вопрос 12. Типы данных в языке С++: целый, вещественный, символьный.

**Тип данных** - множество значений и операций над этими значениями.

![Типы данных в C++](./res/сpp-types.png)

В категории базовых типов выделяют

1) Пустой тип (он же `void` в **С++**).

    Нет и не может быть объектов этого типа. Используется в отклонении (англ. *discard*) результата вычисления (прим. `(void)GetAnswerToTheUniverse();`) и в функциях, не возвращающих значений.

2) Скалярные типы
    - Целочисленные типы: логический (`bool` в **С++**), символьный (`char`, `wchar_t`, `char32_t`, ...), целый (`int`, `short`, ...)
    - Вещественный тип

Отдельно рассмотрим целочисленные и вещественные типы данных в **С++**.

### Целочисленные типы

Стоит отметить, что размеры конкретных типов зависят от платформы. Стандарт **С++** дает ограниченные гарантии на их размер.
Также к ключевым словам типов (`int`, `short`, `long`) могут добавляться квалификаторы `signed` (определяет знаковость) и `unsigned` (определяет беззнаковость). Возможна и комбинация ключевых слов типов: `unsigned long long int`.

| Тип                                                                               | Эквивалентен             | Пояснение                   | Минимальный размер | Размер на *x86-64*   | Диапазон значений (*x86-64*) | Примечание                              |
| --------------------------------------------------------------------------------- | ------------------------ | --------------------------- | ------------------ | -------------------- | ---------------------------- | --------------------------------------- |
| `signed char`                                                                     | `signed char`            | Символьный тип              | 8 бит              | 8 бит                | -128 до 127                  |                                         |
| `unsigned char`                                                                   | `unsigned char`          | Символьный тип              | 8 бит              | 8 бит                | 0 до 255                     |                                         |
| `char8_t`                                                                         | `char8_t`                | Символьный тип для UTF-8    | 8 бит              | 8 бит                | 0 до 255                     | С **С++20**                             |
| `wchar_t`                                                                         | `wchar_t`                | Длинный символьный тип      | -                  | зависит от платформы | зависит от платформы         | На Unix/Linux - 32<br/>На Windows - 16  |
| `char16_t`                                                                        | `char16_t`               | Символьный тип для UTF-16   | 16 бит             | 16 бит               | 0 до 65535                   |                                         |
| `char32_t`                                                                        | `char32_t`               | Символьный тип для UTF-32   | 32 бит             | 32 бит               | 0 до 1114111 (*0x10ffff*)    | Ограничение Unicode                     |
| `short`<br/>`short int`<br/>`signed short`<br/>`signed short int`                 | `short int`              | Целый тип, не больший `int` | 16 бит             | 16 бит               | −32768 до 32767              |                                         |
| `unsigned short`<br/>`unsigned short int`                                         | `unsigned short int`     | Беззнаковый `short`         | 16 бит             | 16 бит               | 0 до 65535                   |                                         |
| `int`<br/>`signed`<br/>`signed int`                                               | `int`                    | Основной целый тип          | 16 бит             | 32 бит               | $-2^{31}$ до $2^{31}-1$      |                                         |
| `unsigned`<br/>`unsigned int`                                                     | `unsigned int`           | Беззнаковый `int`           | 16 бит             | 32 бит               | 0 до $2^{32}-1$              |                                         |
| `long`<br/>`long int`<br/>`signed long`<br/>`signed long int`                     | `long int`               | *Длинное* целое             | 32 бит             | зависит от платформы | зависит от платформы         | На Unix/Linux - 64<br/>Windows API - 32 |
| `unsigned long`<br/>`unsigned long int`                                           | `unsigned long int`      | Беззнаковый `long`          | 32 бит             | зависит от платформы | зависит от платформы         | На Unix/Linux - 64<br/>Windows API - 32 |
| `long long`<br/>`long long int`<br/>`signed long long`<br/>`signed long long int` | `long long int`          | *Дважды длинное* целое      | 64 бит             | 64 бит               | $-2^{63}$ до $2^{63}-1$      |                                         |
| `unsigned long long`<br/>`unsigned long long int`                                 | `unsigned long long int` | Беззнаковый `long long`     | 64 бит             | 64 бит               | 0 до $2^{64}-1$              |                                         |

> Тип `char` занимает по крайней мере 8 бит и ведет себя так же, как и `signed char` или `unsigned char`, но является отдельным типом. При этом конкретная знаковость зависит от платформы и настроек компилятора. На *x86* он обычно знаковый, на *arm* - обычно беззнаковый.

> Логический тип `bool` занимает по крайней мере 8 бит и хранит лишь два значения - `true` или `false`.

Типы в **С++** формируют иерархию по размеру:
```cpp
    1 == sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)
```
Однако стандарт гарантирует лишь минимальное количество бит типов. В частности возможная абсурдная ситуация, когда на платформе один байт* занимает 64 бит и
```cpp
    sizeof(char) == sizeof(short) == sizeof(int) == sizeof(long) == sizeof(long long) == 1
```
Количество бит, которое занимает тип `char` можно проверить макросом `CHAR_BIT`; впрочем, практически все современные системы имеют байт* равным 8 бит.

*под байтом в этом контексте понимается минимально адресуемый объем памяти. Это не обязательно 'байт' в значении объем информации.

### Вещественные типы

Стандарт **С++** определяет следующие типы с плавающей точкой:
1) `float` - вещественный тип одинарной точности. Обычно **IEEE 754** *binary32*.
2) `double` - вещественный тип двойной точности. Обычно **IEEE 754** *binary64*.
3) `long double` - вещественный тип повышенной точности.

    На разных платформах может быть типом четверной точности (**IEEE 754** *binary128*), 80-битным *x87-80 extended precision format* на *x86*, быть эквивалентным `double` или реализован каким-либо другим образом.

