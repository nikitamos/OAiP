## Вопрос 8. Идентификаторы в языке С++, правила наименования

### Идентификаторы

**Идентификатор** - это произвольно длинная последовательность цифр, знаков нижнего подчеркивания букв латиницы верхнего и нижнего регистров (и большинства символов Unicode, если присутствует поддержка платформы), обозначающая имя какой-либо программной сущности (напр. переменной, типа, метки и т. д.).

Пользовательские идентификаторы **не могут** начинаться с **цифры** и содержать внутри себя **пробельные символы**. Также пользовательский идентификатор не может совпадать с каким-либо **ключевым словом** языка С++. Помимо этого не рекомендуется создавать идентификаторы, начинающиеся с символа подчеркивания, поскольку они могут являться внутренней деталью реализации стандартной библиотеки С++ или определяемым компилятором макросом. Аналогично, зарезервированными считаются идентификаторы с 2 нижними подчеркиваниями.

Несмотря на то, что стандарт *не накладывает ограничений на длину* идентификатора, она *все равно может быть ограничена* компилятором и/или компоновщиком. Например, **MSVC** и **Intel C++** поддерживают идентификаторы длиной лишь в **2048** символов, в то время как **GCC** никаких ограничений не накладывает.

### Правила названия

Для увеличения читаемости кода, существуют различные соглашения о названиях переменных типов и других программных сущностей.
Вот, например, правила, рекомендованные по стилю Google (google's codestyle):

| Сущность              | Стиль               | Пример                                                                           |
| --------------------- | ------------------- | -------------------------------------------------------------------------------- |
| Локальная переменная  | **snake_case**      | `int bus_queue_length = 12;`                                                     |
| Тип (напр. структура) | **UpperCamelCase**  | `struct Unit {};`                                                                |
| Функция               | **UpperCamelCase**  | `int GetMagicNumber() { return 69; }`                                            |
| Параметр              | **snake_case**      | `int GetAnswerToTheUniverse(int years_passed) { return 42 + 0 * years_passed; }` |
| С макрос              | **SCREAMING_CASE**  | `#define MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE`                   |
| Константа             | k**UpperCamelCase** | `const bool kIsAndroid = true;`                                                  |
| Поле класса           | **snake_case**_     | `class ProductData { private: int number_of_customers_; };`                      |
| Член перечисления     | k**UpperCamelCase** | `enum Status { kOk = 0, kBadAlloc, kRuntimeError };`                             |
| Пространство имен     | **snake_case**      | `namespace foo_bar { ... }`                                                      |

Существуют и другие подходы, например *венгерская нотация*, по которой различные свойства объекта (например, типы переменных) кодировались в названии этого объекта. Пример:
```cpp
bool bBusy = false; // _b_oolean
const char *szOwner = "This is the owner"; // _z_ero-terminated _s_tring
```

Также стоит придерживаться более общих правил:

1) Следует давать переменным и типам разборчивые имена, конкретные для предметной области.

> Например, создавая очередь покупателей не следует называть переменную `queue`, вместо этого можно использовать более конкретное `customer_queue`.

2) Следует избегать излишних аббревиатур.

> Например, вместо `class UQT { ... };` следует использовать `UnitQuadTree { ... };`.

3) Не стоит называть свои типы и переменные также, как называются типы в стандартной библиотеке.

> Это чревато коллизией имен и сложными в отладке ошибками.