\section{Ключевые слова языка С++, их область применения}

Примечание автора

\textbf{НЕ НУЖНО ПИСАТЬ ВСЮ ТАБЛИЦУ}. Она для справки, по большому
счету. Просто выбрать пару ключевых слов и расписать. Даже лучше
по-подробнее, чем здесь.

\textbf{Ключевое слово} - это предварительно определенный
зарезервированный идентификатор, имеющий специальные значение. Его
нельзя использовать в качестве идентификатора в программе.

Помимо ключевых слов, стандарт С++ начиная c \textbf{C++11} также из
общей массы идентификаторов выделяет \emph{идентификаторы со специальным
значением} (англ. \emph{identifiers with special meaning}). На
сегодняшний день (стандарт \textbf{С++23}) их 4: - \texttt{final}
(запечатывает иерархию наследования); - \texttt{import} (подключает
модуль, начиная с С++20); - \texttt{module} (объявляет модуль, начиная с
С++20); - \texttt{override} (переопределяет член родительского класса).

Эти особые идентификаторы являются ключевыми словами лишь в определенном
контексте, в частности, вот пример их использования в обычном коде:

\begin{verbatim}
#include <iostream>

// пример использования идентификаторов со
// специальным значением в качестве обычных названий переменной
int main() {
  int final = 42;
  long import = 13;
  int module = final + import;
  bool override = true;

  std::cout << (override ? module : -1); // 55

  return 0;
}
\end{verbatim}

Еще следует обозначить ключевые слова - заменители некоторых операторов.
Они предназначены для платформ, поддерживающих только 6-битную ASCII, и
потому не имеющую символов \texttt{\textasciitilde{}\ \&\ \textbar{}} и
т. д.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Ключевое слово & Альтернативное представление \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{and} & \texttt{\&\&} \\
\texttt{and\_eq} & \texttt{\&=} \\
\texttt{bitand} & \texttt{\&} \\
\texttt{bitor} & \texttt{\textbackslash{}\textbar{}} \\
\texttt{compl} & \texttt{\textasciitilde{}} \\
\texttt{not} & \texttt{!} \\
\texttt{not\_eq} & \texttt{!=} \\
\texttt{or} &
\texttt{\textbackslash{}\textbar{}\textbackslash{}\textbar{}} \\
\texttt{or\_eq} & \texttt{\textbackslash{}\textbar{}=} \\
\texttt{xor} & \texttt{\^{}} \\
\texttt{xor\_eq} & \texttt{\^{}=} \\
\end{longtable}

\subsection{\texorpdfstring{Таблица ключевых слов в языке
\textbf{С++}}{Таблица ключевых слов в языке С++}}\label{ux442ux430ux431ux43bux438ux446ux430-ux43aux43bux44eux447ux435ux432ux44bux445-ux441ux43bux43eux432-ux432-ux44fux437ux44bux43aux435-ux441}

\begin{tiny}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.0568}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3596}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.5836}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Ключевое слово
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Использование
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Примечание/пример
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{alignas} & Указывает выравнивание типа & Ошибкой было бы указать
выравнивание меньше естественного. \\
\texttt{alignof} & Возвращает выравнивание типа & \\
\texttt{asm} & Вставка на языке ассемблера & Зависит от платформы. \\
\texttt{auto} & Спецификатор вывода типа автоматически &
\texttt{auto\ i\ =\ 42;\ //\ i\ имеет\ тип\ int} \\
\texttt{bool} & Логический тип & \\
\texttt{break} & Принудительный выход из цикла/ветки \texttt{switch}
& \\
\texttt{case} & Ветка оператора \texttt{switch} & \\
\texttt{catch} & Открывает блок захвата исключений & \\
\texttt{char} & Символьный тип & \\
\texttt{char8\_t} & Символьный тип, строго 8 бит на символ & С
\textbf{С++20}, для представления текста в кодировке UTF-8. \\
\texttt{char16\_t} & Символьный тип, строго 16 бит на символ & Для
представления текста в UTF-16. \\
\texttt{char32\_t} & Символьный тип, строго 32 бита на символ & Для
представления текста в UTF-32. \\
\texttt{class} & Объявляет тип класса & \\
\texttt{concept} & Объявляет концепт & С \textbf{С++20}. Концепты
используются для ограничения параметров шаблонов. \\
\texttt{const} & Спецификатор константности (неизменяемости) & Может
применятся к параметрам, указателям, локальным и глобальным
переменным \\
\texttt{consteval} & Объявляет \emph{немедленную функцию} & С
\textbf{С++20}. Вызов такой функции обязан быть константой времени
компиляции \\
\texttt{constexpr} & Функцию можно вычислить при компиляции & Ошибочно
объявить никогда ни вычислимую при компиляции функцию
\texttt{constexpr} \\
\texttt{constinit} & Утверждает статическую инициализацию & С
\textbf{С++20}. Переменная \texttt{constinit} всегда должна
инициализироваться статически. Только для глобальных переменных и
\texttt{thread\_local} \\
\texttt{const\_cast} & Приведение типов с разными cv-квалификаторами &
Позволяет добавить и/или убрать квалификаторы \texttt{const} и
\texttt{volatile} \\
\texttt{continue} & Досрочно завершает текущую итерацию цикла & \\
\texttt{co\_await} & Приостанавливает корутину до получения значения & C
\textbf{C++20}. \\
\texttt{co\_return} & Завершает корутину & С \textbf{С++20}. \\
\texttt{co\_yield} & Приостанавливает корутину с возвратом значения & С
\textbf{С++20}. \\
\texttt{decltype} & Возвращает тип заданного выражения на этапе
компиляции & \\
\texttt{default} & Определяет ветку по умолчанию в операторе
\texttt{switch}. Также указывает использовать реализацию по умолчанию
& \\
\texttt{delete} & Явным образом удаляет сгенерированную компилятором
реализацию по умолчанию & \\
\texttt{do} & Часть объявления цикла c постусловием & \\
\texttt{double} & Вещественный тип двойной точности & \\
\texttt{dynamic\_cast} & Приведение типов в иерархии наследования & \\
\texttt{else} & Ветка иначе в условном операторе & \\
\texttt{enum} & Объявляет перечисление & \\
\texttt{explicit} & Отличает конструктор с одним параметром от
перегруженного оператора приведения типов & \\
\texttt{export} & До \textbf{С++11} использовалось в шаблонах; после
\textbf{С++20} используется для экспорта кода в модулях & \\
\texttt{extern} & Определяет \emph{внешнюю компоновку} & Переменные и
функции с внешней компоновкой доступны из этого объектного модуля в
других. \\
\texttt{false} & Литерал \emph{ложь} & \\
\texttt{float} & Вещественный тип одинарной точности & \\
\texttt{for} & Объявляет цикл с параметром и цикл по коллекции
(\emph{range-based for}) & \\
\texttt{friend} & Спецификатор видимости; позволяет дать другому типу
(функции) доступ к приватным полям класса & \\
\texttt{goto} & Оператор безусловного перехода & \\
\texttt{if} & Объявляет условный оператор & \\
\texttt{inline} & Функция, помеченная inline будет встроена в местах
вызова & Компилятор имеет право (по соображению сохранения двоичного
интерфейса приложения, ABI) проигнорировать этот спецификатор. \\
\texttt{int} & Целый тип, обычно 4 байта в размере & \\
\texttt{long} & Целый тип, не меньше чем int & \\
\texttt{mutable} & Спецификатор, позволяющий изменять поле, даже если
объект константен & \\
\texttt{namespace} & Определяет или подключает пространство имен & \\
\texttt{new} & Оператор выделения памяти & \\
\texttt{noexcept} & Спецификатор отсутствия исключений & Возвращает
\texttt{true}, если выражение не бросает исключений. Также используется
как часть объявления функции, чтобы обозначить, что она не бросает
исключений. \\
\texttt{nullptr} & Литерал \emph{0-ого указателя} & \\
\texttt{operator} & Используется в переопределении операторов & \\
\texttt{private} & Спецификатор видимости; член (наследование)
недоступен(-о) за пределами класса & \\
\texttt{protected} & Спецификатор видимости; член (наследование)
доступен(-о) только дочерним классам & \\
\texttt{public} & Спецификатор видимости; член (наследование)
доступен(-о) & \\
\texttt{register} & Спецификатор локальной переменной/параметра &
Показывает компилятору, что указанная переменная/параметр часто
используется, и потому ее следует поместить в регистр процессора. \\
\texttt{reinterpret\_cast} & Приведение несвязных типов & Не
рекомендуется. \\
\texttt{requires} & Используется в концептах & \\
\texttt{return} & Возврат значения из функции и лямбда-выражения & \\
\texttt{short} & Целый тип, не больше, чем \texttt{int} & \\
\texttt{signed} & Показывает, что следующий целый тип знаковый & \\
\texttt{sizeof} & Оператор получения размера типа & \\
\texttt{static} & Определяет \emph{внутреннюю компоновку}. Также
объявляет статический член класса (для его вызова не нужен объект) & при
внутренней компоновке глобальные переменные и функции недоступны извне
объектного модуля. \\
\texttt{static\_assert} & Определяет условие на этапе компиляции & В
случае ложности условия, завершает компиляцию с ошибкой. Вторым
аргументом можно передать строку - пользовательское сообщение об
ошибке. \\
\texttt{static\_cast} & Приведение типов & \\
\texttt{struct} & Объявляет структуру & \\
\texttt{switch} & Объявляет оператор выбора \texttt{switch} & \\
\texttt{template} & Объявляет шаблон & \\
\texttt{this} & Указатель на текущий объект (в методе) & \\
\texttt{thread\_local} & Спецификатор, делающий переменную локальной для
каждого потока & \\
\texttt{throw} & Бросает исключение & \\
\texttt{true} & Литерал \emph{истина} & \\
\texttt{try} & Объявляет защищаемый блок оператора \texttt{try-catch}
& \\
\texttt{typedef} & Дает существующему типу новое имя (т.е. псевдоним)
& \\
\texttt{typeid} & Получает информацию о типе & \\
\texttt{typename} & Используется в шаблонах & \\
\texttt{union} & Объявляет объединение & \\
\texttt{unsigned} & Показывает, что следующий целый тип беззнаковый & \\
\texttt{using} & Подключает пространство имен, член пространства имен.
Также может давать типам псевдонимы & \\
\texttt{virtual} & Создает виртуальный метод & Виртуальные методы можно
переопределять в дочерних классах; то, какой конкретно метод вызовется,
зависит от типа конкретного объекта, даже при приведении к родительскому
типу. \\
\texttt{void} & Определяет тип \emph{ничто}. & Нет и не может быть
объектов этого типа. Также используется для функций, не возвращающих
значения. \\
\texttt{volatile} & Спецификатор, показывающий, что переменная может
изменится под влиянием внешних причин & \texttt{volatile} переменные не
могут быть оптимизированы, поскольку компилятор не может строить о них
предположения. Значения таких переменных для компилятора могут
изменяться непредсказуемо. \\
\texttt{wchar\_t} & Тип символа, хранит не меньше, чем \texttt{char} &
Понимается как тип символов платформно-зависимой расширенной кодовой
таблицы. \\
\texttt{while} & Участвует в объявлении циклов с пред- и постусловием
& \\
\end{longtable}
\end{tiny}

Не считая альтернативные формы некоторых операторов и идентификаторы с
особым значением, всего в \textbf{С++} \textbf{81 ключевое слово}.
